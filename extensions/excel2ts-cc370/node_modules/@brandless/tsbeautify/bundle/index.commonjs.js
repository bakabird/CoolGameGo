'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tsutility = require('@brandless/tsutility');

/*
Expecting the following files to mark themselves as loaded:
DummyClass.ts
TsBeautifier.ts
Token.ts
TsBeautifyOptions.ts
Extensions\StringExtensions.ts
*/
var queue;
function __TsBeautify_Types_typeLoaded(name) {
    // __allTypesCount--;
    // && __allTypesCount === 0
    if (queue) {
        queue.forEach(function (element) {
            element();
        });
        queue = new Array();
    }
}

var DummyClass = /** @class */ (function () {
    function DummyClass() {
    }
    DummyClass.FunctionsDeclared = function () {
        return new Array();
    };
    DummyClass.PropertiesDeclared = function () {
        return new Array();
    };
    DummyClass.prototype.toJSON = function () {
        return tsutility.Serialization.PrepareForJson(this, DummyClass);
    };
    DummyClass.GenericTypeParameters = [];
    DummyClass.ClassName = "DummyClass";
    DummyClass.ClassNameType = DummyClass;
    return DummyClass;
}());
__TsBeautify_Types_typeLoaded();

var TsBeautifyOptions = /** @class */ (function () {
    function TsBeautifyOptions() {
        this._TsBeautifyOptions_OpenBlockOnNewLine = false;
        this._TsBeautifyOptions_PreserveNewlines = false;
    }
    TsBeautifyOptions.FunctionsDeclared = function () {
        return new Array("get_OpenBlockOnNewLine", "set_OpenBlockOnNewLine", "get_IndentSize", "set_IndentSize", "get_IndentChar", "set_IndentChar", "get_IndentLevel", "set_IndentLevel", "get_PreserveNewlines", "set_PreserveNewlines");
    };
    TsBeautifyOptions.PropertiesDeclared = function () {
        return new Array(new tsutility.PropertyInfo("_TsBeautifyOptions_OpenBlockOnNewLine", TsBeautifyOptions, tsutility.TypeMetadata.Parse("boolean"), false, false), new tsutility.PropertyInfo("_TsBeautifyOptions_IndentSize", TsBeautifyOptions, tsutility.TypeMetadata.Parse("number"), false, false), new tsutility.PropertyInfo("_TsBeautifyOptions_IndentChar", TsBeautifyOptions, tsutility.TypeMetadata.Parse("number"), false, false), new tsutility.PropertyInfo("_TsBeautifyOptions_IndentLevel", TsBeautifyOptions, tsutility.TypeMetadata.Parse("number"), false, false), new tsutility.PropertyInfo("_TsBeautifyOptions_PreserveNewlines", TsBeautifyOptions, tsutility.TypeMetadata.Parse("boolean"), false, false), new tsutility.PropertyInfo("<OpenBlockOnNewLine>k__BackingField", TsBeautifyOptions, tsutility.TypeMetadata.Parse("System.Boolean"), false, true), new tsutility.PropertyInfo("OpenBlockOnNewLine", TsBeautifyOptions, tsutility.TypeMetadata.Parse("System.Boolean"), true, false), new tsutility.PropertyInfo("<IndentSize>k__BackingField", TsBeautifyOptions, tsutility.TypeMetadata.Parse("System.Nullable?"), false, true), new tsutility.PropertyInfo("IndentSize", TsBeautifyOptions, tsutility.TypeMetadata.Parse("System.Nullable?"), true, false), new tsutility.PropertyInfo("<IndentChar>k__BackingField", TsBeautifyOptions, tsutility.TypeMetadata.Parse("System.Nullable?"), false, true), new tsutility.PropertyInfo("IndentChar", TsBeautifyOptions, tsutility.TypeMetadata.Parse("System.Nullable?"), true, false), new tsutility.PropertyInfo("<IndentLevel>k__BackingField", TsBeautifyOptions, tsutility.TypeMetadata.Parse("System.Nullable?"), false, true), new tsutility.PropertyInfo("IndentLevel", TsBeautifyOptions, tsutility.TypeMetadata.Parse("System.Nullable?"), true, false), new tsutility.PropertyInfo("<PreserveNewlines>k__BackingField", TsBeautifyOptions, tsutility.TypeMetadata.Parse("System.Nullable?"), false, true), new tsutility.PropertyInfo("PreserveNewlines", TsBeautifyOptions, tsutility.TypeMetadata.Parse("System.Nullable?"), true, false));
    };
    Object.defineProperty(TsBeautifyOptions.prototype, "OpenBlockOnNewLine", {
        get: function () {
            return this.TsBeautifyOptions_OpenBlockOnNewLineGetter();
        },
        set: function (value) {
            this.TsBeautifyOptions_OpenBlockOnNewLineSetter(value);
        },
        enumerable: true,
        configurable: true
    });
    TsBeautifyOptions.prototype.TsBeautifyOptions_OpenBlockOnNewLineGetter = function () {
        return this._TsBeautifyOptions_OpenBlockOnNewLine;
    };
    TsBeautifyOptions.prototype.TsBeautifyOptions_OpenBlockOnNewLineSetter = function (value) {
        this._TsBeautifyOptions_OpenBlockOnNewLine = value;
    };
    Object.defineProperty(TsBeautifyOptions.prototype, "IndentSize", {
        get: function () {
            return this.TsBeautifyOptions_IndentSizeGetter();
        },
        set: function (value) {
            this.TsBeautifyOptions_IndentSizeSetter(value);
        },
        enumerable: true,
        configurable: true
    });
    TsBeautifyOptions.prototype.TsBeautifyOptions_IndentSizeGetter = function () {
        return this._TsBeautifyOptions_IndentSize;
    };
    TsBeautifyOptions.prototype.TsBeautifyOptions_IndentSizeSetter = function (value) {
        this._TsBeautifyOptions_IndentSize = value;
    };
    Object.defineProperty(TsBeautifyOptions.prototype, "IndentChar", {
        get: function () {
            return this.TsBeautifyOptions_IndentCharGetter();
        },
        set: function (value) {
            this.TsBeautifyOptions_IndentCharSetter(value);
        },
        enumerable: true,
        configurable: true
    });
    TsBeautifyOptions.prototype.TsBeautifyOptions_IndentCharGetter = function () {
        return this._TsBeautifyOptions_IndentChar;
    };
    TsBeautifyOptions.prototype.TsBeautifyOptions_IndentCharSetter = function (value) {
        this._TsBeautifyOptions_IndentChar = value;
    };
    Object.defineProperty(TsBeautifyOptions.prototype, "IndentLevel", {
        get: function () {
            return this.TsBeautifyOptions_IndentLevelGetter();
        },
        set: function (value) {
            this.TsBeautifyOptions_IndentLevelSetter(value);
        },
        enumerable: true,
        configurable: true
    });
    TsBeautifyOptions.prototype.TsBeautifyOptions_IndentLevelGetter = function () {
        return this._TsBeautifyOptions_IndentLevel;
    };
    TsBeautifyOptions.prototype.TsBeautifyOptions_IndentLevelSetter = function (value) {
        this._TsBeautifyOptions_IndentLevel = value;
    };
    Object.defineProperty(TsBeautifyOptions.prototype, "PreserveNewlines", {
        get: function () {
            return this.TsBeautifyOptions_PreserveNewlinesGetter();
        },
        set: function (value) {
            this.TsBeautifyOptions_PreserveNewlinesSetter(value);
        },
        enumerable: true,
        configurable: true
    });
    TsBeautifyOptions.prototype.TsBeautifyOptions_PreserveNewlinesGetter = function () {
        return this._TsBeautifyOptions_PreserveNewlines;
    };
    TsBeautifyOptions.prototype.TsBeautifyOptions_PreserveNewlinesSetter = function (value) {
        this._TsBeautifyOptions_PreserveNewlines = value;
    };
    TsBeautifyOptions.prototype.toJSON = function () {
        return tsutility.Serialization.PrepareForJson(this, TsBeautifyOptions);
    };
    TsBeautifyOptions.GenericTypeParameters = [];
    TsBeautifyOptions.ClassName = "TsBeautifyOptions";
    TsBeautifyOptions.ClassNameType = TsBeautifyOptions;
    return TsBeautifyOptions;
}());
__TsBeautify_Types_typeLoaded();

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

function __values(o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

var StringExtensions = /** @class */ (function () {
    function StringExtensions() {
    }
    StringExtensions.FunctionsDeclared = function () {
        return new Array("StartsWithAt");
    };
    StringExtensions.PropertiesDeclared = function () {
        return new Array();
    };
    StringExtensions.StartsWithAt = function (str, toLookFor, atPosititon) {
        var pos = atPosititon;
        for (var i = 0; i < toLookFor.length; i++) {
            var ch = tsutility.StringUtil.CharCodeAt(toLookFor, i);
            if (tsutility.StringUtil.CharCodeAt(str, pos) != ch) {
                return (false);
            }
            pos++;
        }
        return (true);
    };
    StringExtensions.prototype.toJSON = function () {
        return tsutility.Serialization.PrepareForJson(this, StringExtensions);
    };
    StringExtensions.GenericTypeParameters = [];
    StringExtensions.ClassName = "StringExtensions";
    StringExtensions.ClassNameType = StringExtensions;
    return StringExtensions;
}());
__TsBeautify_Types_typeLoaded();

var TsBeautifierInstance = /** @class */ (function () {
    function TsBeautifierInstance(jsSourceText, options, interpolation) {
        if (options === void 0) { options = null; }
        if (interpolation === void 0) { interpolation = false; }
        this._optPreserveNewlines = false;
        this._doBlockJustClosed = false;
        this._genericsDepth = 0;
        this._ifLineFlag = false;
        this._indentLevel = 0;
        this._isImportBlock = false;
        this._secondToLastCharIndex = -1;
        this._currentInputCharIndex = -1;
        this._parserPos = 0;
        this._TsBeautifierInstance_Interpolation = false;
        this._token = new Token(null, TokenType.BlockComment);
        this._TsBeautifierInstance_Interpolation = interpolation;
        options = tsutility.Coalesce(options, function () { return new TsBeautifyOptions(); });
        this._options = options;
        var optIndentSize = tsutility.Coalesce(options.IndentSize, function () { return 4; });
        var optIndentChar = tsutility.Coalesce(options.IndentChar, function () { return ' '.charCodeAt(0); });
        var optIndentLevel = tsutility.Coalesce(options.IndentLevel, function () { return 0; });
        this._optPreserveNewlines = tsutility.Coalesce(options.PreserveNewlines, function () { return true; });
        this._output = new tsutility.StringBuilder();
        this._modes = new Array();
        this._indentString = "";
        while (optIndentSize > 0) {
            this._indentString += tsutility.StringUtil.EnsureChar(optIndentChar);
            optIndentSize -= 1;
        }
        this._indentLevel = optIndentLevel;
        this._input = jsSourceText;
        this._lastType = TokenType.StartExpression; // last token type
        this._lastText = ""; // last token text
        this._doBlockJustClosed = false;
        this._whitespace = TsBeautifierInstance.ToLookup(TsBeautifierInstance.WhitespaceChars);
        this._whitespaceChars = TsBeautifierInstance.ToCharLookup(this._whitespace);
        this._wordchar = TsBeautifierInstance.ToLookup(TsBeautifierInstance.WordChars);
        this._digits = TsBeautifierInstance.ToLookup(TsBeautifierInstance.Chars);
        this._genericsBrackets = TsBeautifierInstance.ToLookup(TsBeautifierInstance.GenericsChars);
        this._generics = TsBeautifierInstance.ToLookup(TsBeautifierInstance.WhitespaceChars + TsBeautifierInstance.WordChars + "," + TsBeautifierInstance.GenericsChars);
        this._digitsChars = TsBeautifierInstance.ToCharLookup(this._digits);
        this._wordcharChars = TsBeautifierInstance.ToCharLookup(this._wordchar);
        this._genericsChars = TsBeautifierInstance.ToCharLookup(this._generics);
        this._genericsBracketsChars = TsBeautifierInstance.ToCharLookup(this._genericsBrackets);
        // <!-- is a special case (ok, it's a minor hack actually)
        this._punctuation = TsBeautifierInstance.ArrayToLookup("=> + - * / % & ++ -- = += -= *= /= %= == === != !== > < >= <= >> << >>> >>>= >>= <<= && &= | || ?? ! !! , : ? ^ ^= |= ::".split(' '));
        // words which should always start on new line.
        this._lineStarters = TsBeautifierInstance.ArrayToLookup("@test,import,let,continue,try,throw,return,var,if,switch,case,default,for,while,break,function".split(','));
        // states showing if we are currently in expression (i.e. "if" case) - 'EXPRESSION', or in usual block (like, procedure), 'BLOCK'.
        // some formatting depends on that.
        this._currentMode = TsMode.Block;
        this._modes.push(this._currentMode);
        this._parserPos = 0;
    }
    TsBeautifierInstance.FunctionsDeclared = function () {
        return new Array("get_Interpolation", "get_InGenerics", "get_SecondToLastChar", "get_CurrentInputChar", "ToLookup", "ArrayToLookup", "ToCharLookup", "Parse", "PrintNewLineOrSpace", "TrimOutput", "PrintNewLine", "PrintSpace", "PrintToken", "Indent", "Unindent", "RemoveIndent", "SetMode", "RestoreMode", "IsTernaryOperation", "SkipWhiteSpace", "GetNextToken", "SkipWhiteSpace2", "SetToken", "At", "Beautify");
    };
    TsBeautifierInstance.PropertiesDeclared = function () {
        return new Array(new tsutility.PropertyInfo("_TsBeautifierInstance_Interpolation", TsBeautifierInstance, tsutility.TypeMetadata.Parse("boolean"), false, false), new tsutility.PropertyInfo("_TsBeautifierInstance_InGenerics", TsBeautifierInstance, tsutility.TypeMetadata.Parse("boolean"), false, false), new tsutility.PropertyInfo("WhitespaceChars", TsBeautifierInstance, tsutility.TypeMetadata.Parse("System.String"), false, true), new tsutility.PropertyInfo("WordChars", TsBeautifierInstance, tsutility.TypeMetadata.Parse("System.String"), false, true), new tsutility.PropertyInfo("Chars", TsBeautifierInstance, tsutility.TypeMetadata.Parse("System.String"), false, true), new tsutility.PropertyInfo("GenericsChars", TsBeautifierInstance, tsutility.TypeMetadata.Parse("System.String"), false, true), new tsutility.PropertyInfo("_digits", TsBeautifierInstance, tsutility.TypeMetadata.Parse("System.Collections.Generic.Dictionary<System.String, System.Boolean>"), false, true), new tsutility.PropertyInfo("_digitsChars", TsBeautifierInstance, tsutility.TypeMetadata.Parse("System.Collections.Generic.Dictionary<System.Char, System.Boolean>"), false, true), new tsutility.PropertyInfo("_generics", TsBeautifierInstance, tsutility.TypeMetadata.Parse("System.Collections.Generic.Dictionary<System.String, System.Boolean>"), false, true), new tsutility.PropertyInfo("_genericsBrackets", TsBeautifierInstance, tsutility.TypeMetadata.Parse("System.Collections.Generic.Dictionary<System.String, System.Boolean>"), false, true), new tsutility.PropertyInfo("_genericsBracketsChars", TsBeautifierInstance, tsutility.TypeMetadata.Parse("System.Collections.Generic.Dictionary<System.Char, System.Boolean>"), false, true), new tsutility.PropertyInfo("_genericsChars", TsBeautifierInstance, tsutility.TypeMetadata.Parse("System.Collections.Generic.Dictionary<System.Char, System.Boolean>"), false, true), new tsutility.PropertyInfo("_indentString", TsBeautifierInstance, tsutility.TypeMetadata.Parse("System.String"), false, true), new tsutility.PropertyInfo("_input", TsBeautifierInstance, tsutility.TypeMetadata.Parse("System.String"), false, true), new tsutility.PropertyInfo("_lineStarters", TsBeautifierInstance, tsutility.TypeMetadata.Parse("System.Collections.Generic.Dictionary<System.String, System.Boolean>"), false, true), new tsutility.PropertyInfo("_modes", TsBeautifierInstance, tsutility.TypeMetadata.Parse("System.Collections.Generic.Stack<TsBeautify.TsMode>"), false, true), new tsutility.PropertyInfo("_options", TsBeautifierInstance, tsutility.TypeMetadata.Parse("TsBeautify.TsBeautifyOptions"), false, true), new tsutility.PropertyInfo("_optPreserveNewlines", TsBeautifierInstance, tsutility.TypeMetadata.Parse("System.Boolean"), false, true), new tsutility.PropertyInfo("_output", TsBeautifierInstance, tsutility.TypeMetadata.Parse("System.Text.StringBuilder"), false, true), new tsutility.PropertyInfo("_punctuation", TsBeautifierInstance, tsutility.TypeMetadata.Parse("System.Collections.Generic.Dictionary<System.String, System.Boolean>"), false, true), new tsutility.PropertyInfo("_whitespace", TsBeautifierInstance, tsutility.TypeMetadata.Parse("System.Collections.Generic.Dictionary<System.String, System.Boolean>"), false, true), new tsutility.PropertyInfo("_whitespaceChars", TsBeautifierInstance, tsutility.TypeMetadata.Parse("System.Collections.Generic.Dictionary<System.Char, System.Boolean>"), false, true), new tsutility.PropertyInfo("_wordchar", TsBeautifierInstance, tsutility.TypeMetadata.Parse("System.Collections.Generic.Dictionary<System.String, System.Boolean>"), false, true), new tsutility.PropertyInfo("_wordcharChars", TsBeautifierInstance, tsutility.TypeMetadata.Parse("System.Collections.Generic.Dictionary<System.Char, System.Boolean>"), false, true), new tsutility.PropertyInfo("_currentMode", TsBeautifierInstance, tsutility.TypeMetadata.Parse("TsBeautify.TsMode"), false, true), new tsutility.PropertyInfo("_doBlockJustClosed", TsBeautifierInstance, tsutility.TypeMetadata.Parse("System.Boolean"), false, true), new tsutility.PropertyInfo("_genericsDepth", TsBeautifierInstance, tsutility.TypeMetadata.Parse("System.Int32"), false, true), new tsutility.PropertyInfo("_ifLineFlag", TsBeautifierInstance, tsutility.TypeMetadata.Parse("System.Boolean"), false, true), new tsutility.PropertyInfo("_indentLevel", TsBeautifierInstance, tsutility.TypeMetadata.Parse("System.Int32"), false, true), new tsutility.PropertyInfo("_isImportBlock", TsBeautifierInstance, tsutility.TypeMetadata.Parse("System.Boolean"), false, true), new tsutility.PropertyInfo("_secondToLastChar", TsBeautifierInstance, tsutility.TypeMetadata.Parse("System.Char"), false, true), new tsutility.PropertyInfo("_secondToLastCharIndex", TsBeautifierInstance, tsutility.TypeMetadata.Parse("System.Int32"), false, true), new tsutility.PropertyInfo("_currentInputChar", TsBeautifierInstance, tsutility.TypeMetadata.Parse("System.Char"), false, true), new tsutility.PropertyInfo("_currentInputCharIndex", TsBeautifierInstance, tsutility.TypeMetadata.Parse("System.Int32"), false, true), new tsutility.PropertyInfo("_lastText", TsBeautifierInstance, tsutility.TypeMetadata.Parse("System.String"), false, true), new tsutility.PropertyInfo("_lastType", TsBeautifierInstance, tsutility.TypeMetadata.Parse("TsBeautify.TokenType"), false, true), new tsutility.PropertyInfo("_parserPos", TsBeautifierInstance, tsutility.TypeMetadata.Parse("System.Int32"), false, true), new tsutility.PropertyInfo("_token", TsBeautifierInstance, tsutility.TypeMetadata.Parse("TsBeautify.Token"), false, true), new tsutility.PropertyInfo("_tokenText", TsBeautifierInstance, tsutility.TypeMetadata.Parse("System.String"), false, true), new tsutility.PropertyInfo("<Interpolation>k__BackingField", TsBeautifierInstance, tsutility.TypeMetadata.Parse("System.Boolean"), false, true), new tsutility.PropertyInfo("Interpolation", TsBeautifierInstance, tsutility.TypeMetadata.Parse("System.Boolean"), true, false), new tsutility.PropertyInfo("InGenerics", TsBeautifierInstance, tsutility.TypeMetadata.Parse("System.Boolean"), false, false), new tsutility.PropertyInfo("SecondToLastChar", TsBeautifierInstance, tsutility.TypeMetadata.Parse("System.Char"), true, false), new tsutility.PropertyInfo("CurrentInputChar", TsBeautifierInstance, tsutility.TypeMetadata.Parse("System.Char"), true, false));
    };
    Object.defineProperty(TsBeautifierInstance.prototype, "Interpolation", {
        get: function () {
            return this.TsBeautifierInstance_InterpolationGetter();
        },
        enumerable: true,
        configurable: true
    });
    TsBeautifierInstance.prototype.TsBeautifierInstance_InterpolationGetter = function () {
        return this._TsBeautifierInstance_Interpolation;
    };
    TsBeautifierInstance.prototype.TsBeautifierInstance_InterpolationSetter = function (value) {
        this._TsBeautifierInstance_Interpolation = value;
    };
    Object.defineProperty(TsBeautifierInstance.prototype, "InGenerics", {
        get: function () {
            return this.TsBeautifierInstance_InGenericsGetter();
        },
        enumerable: true,
        configurable: true
    });
    TsBeautifierInstance.prototype.TsBeautifierInstance_InGenericsGetter = function () {
        return this._genericsDepth > 0;
    };
    Object.defineProperty(TsBeautifierInstance.prototype, "SecondToLastChar", {
        get: function () {
            return this.TsBeautifierInstance_SecondToLastCharGetter();
        },
        enumerable: true,
        configurable: true
    });
    TsBeautifierInstance.prototype.TsBeautifierInstance_SecondToLastCharGetter = function () {
        if (this._secondToLastCharIndex != this._output.Length) {
            this._secondToLastCharIndex = this._output.Length;
            this._secondToLastChar = tsutility.StringUtil.CharCodeAt(this._output, this._output.Length - 1);
        }
        return (this._secondToLastChar);
    };
    Object.defineProperty(TsBeautifierInstance.prototype, "CurrentInputChar", {
        get: function () {
            return this.TsBeautifierInstance_CurrentInputCharGetter();
        },
        enumerable: true,
        configurable: true
    });
    TsBeautifierInstance.prototype.TsBeautifierInstance_CurrentInputCharGetter = function () {
        if (this._currentInputCharIndex != this._parserPos) {
            this._currentInputCharIndex = this._parserPos;
            this._currentInputChar = tsutility.StringUtil.CharCodeAt(this._input, this._parserPos);
        }
        return (this._currentInputChar);
    };
    TsBeautifierInstance.ToLookup = function (str) {
        var chars = tsutility.StringUtil.ToCharArray(str);
        var dic = new Map();
        for (var i = 0; i < chars.length; i++) {
            dic.set((tsutility.StringUtil.EnsureChar(tsutility.StringUtil.CharCodeAt(chars, i))), true);
        }
        return dic;
    };
    TsBeautifierInstance.ArrayToLookup = function (str) {
        var strings = tsutility.Enumerable.ToList(str);
        var dic = new Map();
        for (var i = 0; i < strings.length; i++) {
            dic.set(strings[i], true);
        }
        return dic;
    };
    TsBeautifierInstance.ToCharLookup = function (lookup) {
        var e_1, _a;
        var dic = new Map();
        try {
            for (var _b = __values(lookup.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {
                var _d = __read(_c.value, 2), _ts1Key = _d[0], _ts1Value = _d[1];
                dic.set(tsutility.StringUtil.CharCodeAt(_ts1Key, 0), true);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return dic;
    };
    TsBeautifierInstance.prototype.Parse = function () {
        var lastWord = "";
        var varLine = false;
        var varLineTainted = false;
        var inCase = false;
        var genericsDepth = 0;
        var interpolation = this.Interpolation;
        while (true) {
            this.GetNextToken();
            this._tokenText = this._token.Value;
            var tokenType = this._token.TokenType;
            if (tokenType == TokenType.Word && (this._lineStarters.has(this._token.Value))) {
                this.PrintNewLine();
            }
            if (tokenType == TokenType.EndBlock && interpolation && this._indentLevel == 1) {
                return;
            }
            if (tokenType == TokenType.EndOfFile) {
                break;
            }
            switch (tokenType) {
                case TokenType.StartExpression:
                    varLine = false;
                    this.SetMode(TsMode.Expression);
                    if (this._lastText == ";" || this._lastType == TokenType.StartBlock) {
                        this.PrintNewLine();
                    }
                    else if (this._lastType == TokenType.EndExpression || this._lastType == TokenType.StartExpression) ;
                    else if (this._lastType != TokenType.Word && this._lastType != TokenType.Operator && this._lastType != TokenType.Generics) {
                        this.PrintSpace();
                    }
                    else if ((this._lineStarters.has(lastWord))) {
                        this.PrintSpace();
                    }
                    this.PrintToken();
                    break;
                case TokenType.EndExpression:
                    this.PrintToken();
                    this.RestoreMode();
                    break;
                case TokenType.StartImport:
                case TokenType.EndImport:
                    this.PrintSpace();
                    this._output.Append(this._token.Value);
                    this.PrintSpace();
                    break;
                case TokenType.StartBlock:
                    if (lastWord == "do") {
                        this.SetMode(TsMode.DoBlock);
                    }
                    else {
                        this.SetMode(TsMode.Block);
                    }
                    if (this._lastType != TokenType.Operator && this._lastType != TokenType.StartExpression) {
                        if (this._lastType == TokenType.StartBlock) {
                            this.PrintNewLine();
                        }
                        else {
                            if (this._options.OpenBlockOnNewLine) {
                                this.PrintNewLine();
                            }
                            else {
                                this.PrintSpace();
                            }
                        }
                    }
                    this.PrintToken();
                    this.Indent();
                    break;
                case TokenType.EndBlock:
                    if (this._lastType == TokenType.StartBlock) {
                        // nothing
                        this.TrimOutput();
                        this.Unindent();
                    }
                    else {
                        this.Unindent();
                        this.PrintNewLine();
                    }
                    this.PrintToken();
                    this.RestoreMode();
                    break;
                case TokenType.Word:
                    if (this._doBlockJustClosed) {
                        // do {} ## while ()
                        this.PrintSpace();
                        this.PrintToken();
                        this.PrintSpace();
                        this._doBlockJustClosed = false;
                        break;
                    }
                    if ((this._tokenText == "extends" || this._tokenText == ":") && this._lastText == ">") {
                        this.PrintSpace();
                    }
                    if (this._tokenText == "case" || this._tokenText == "default") {
                        if (this._lastText == ":") {
                            // switch cases following one another
                            this.RemoveIndent();
                        }
                        else {
                            // case statement starts in the same line where switch
                            this.Unindent();
                            this.PrintNewLine();
                            this.Indent();
                        }
                        this.PrintToken();
                        inCase = true;
                        break;
                    }
                    var prefix = "NONE";
                    if (this._lastType == TokenType.EndBlock) {
                        if (!(tsutility.Enumerable.Contains(["else", "catch", "finally"], (this._tokenText.toLowerCase())))) {
                            prefix = "NEWLINE";
                        }
                        else {
                            prefix = "SPACE";
                            this.PrintSpace();
                        }
                    }
                    else if (this._lastType == TokenType.SemiColon && (this._currentMode == TsMode.Block || this._currentMode == TsMode.DoBlock)) {
                        prefix = "NEWLINE";
                    }
                    else if (this._lastType == TokenType.SemiColon && this._currentMode == TsMode.Expression) {
                        prefix = "SPACE";
                    }
                    else if (this._lastType == TokenType.String) {
                        prefix = "NEWLINE";
                    }
                    else if (this._lastType == TokenType.Word) {
                        prefix = "SPACE";
                    }
                    else if (this._lastType == TokenType.StartBlock) {
                        prefix = "NEWLINE";
                    }
                    else if (this._lastType == TokenType.EndExpression) {
                        this.PrintSpace();
                        prefix = "NEWLINE";
                    }
                    if (this._lastType != TokenType.EndBlock && (tsutility.Enumerable.Contains(["else", "catch", "finally"], (this._tokenText.toLowerCase())))) {
                        this.PrintNewLine();
                    }
                    else if ((this._lineStarters.has(this._tokenText)) || prefix == "NEWLINE") {
                        if (this._lastText == "else") {
                            // no need to force newline on else break
                            this.PrintSpace();
                        }
                        else if ((this._lastType == TokenType.StartExpression || this._lastText == "=" || this._lastText == ",") && this._tokenText == "function") ;
                        else if (this._lastType == TokenType.Word && (this._lastText == "return" || this._lastText == "throw")) {
                            // no newline between "return nnn"
                            this.PrintSpace();
                        }
                        else if (this._lastType != TokenType.EndExpression) {
                            if ((this._lastType != TokenType.StartExpression || this._tokenText != "var") && this._lastText != ":") {
                                if (this._tokenText == "if" && this._lastType == TokenType.Word && lastWord == "else") {
                                    this.PrintSpace();
                                }
                                else {
                                    this.PrintNewLine();
                                }
                            }
                        }
                        else {
                            if ((this._lineStarters.has(this._tokenText)) && this._lastText != ")") {
                                this.PrintNewLine();
                            }
                        }
                    }
                    else if (prefix == "SPACE") {
                        this.PrintSpace();
                    }
                    this.PrintToken();
                    lastWord = this._tokenText;
                    if (this._tokenText == "var") {
                        varLine = true;
                        varLineTainted = false;
                    }
                    if (this._tokenText == "if" || this._tokenText == "else") {
                        this._ifLineFlag = true;
                    }
                    break;
                case TokenType.SemiColon:
                    this.PrintToken();
                    varLine = false;
                    break;
                case TokenType.String:
                    if (this._lastType == TokenType.StartBlock || this._lastType == TokenType.EndBlock || this._lastType == TokenType.SemiColon) {
                        this.PrintNewLine();
                    }
                    else if (this._lastType == TokenType.Word && this._lastText != "$") {
                        this.PrintSpace();
                    }
                    this.PrintToken();
                    break;
                case TokenType.Generics:
                    if (this._token.Value == "<") {
                        if (genericsDepth == 0) {
                            if (this._lastText == "}") {
                                this.PrintNewLine();
                            }
                            if (this._lastType == TokenType.Word && this._lastText == "return") {
                                this.PrintSpace();
                            }
                        }
                        this._output.Append(this._token.Value);
                        genericsDepth++;
                    }
                    else {
                        this._output.Append(this._token.Value);
                        genericsDepth--;
                    }
                    break;
                case TokenType.Operator:
                    var startDelim = true;
                    var endDelim = true;
                    if (varLine && this._tokenText != ",") {
                        varLineTainted = true;
                        if (this._tokenText == ":") {
                            varLine = false;
                        }
                    }
                    if (varLine && this._tokenText == "," && this._currentMode == TsMode.Expression) {
                        varLineTainted = false;
                    }
                    if (this._tokenText == ":" && inCase) {
                        this.PrintToken(); // colon really asks for separate treatment
                        this.PrintNewLine();
                        inCase = false;
                        break;
                    }
                    if (this._tokenText == "::") {
                        // no spaces around exotic namespacing syntax operator
                        this.PrintToken();
                        break;
                    }
                    if (this._tokenText == ",") {
                        if (varLine) {
                            if (varLineTainted) {
                                this.PrintToken();
                                this.PrintNewLine();
                                varLineTainted = false;
                            }
                            else {
                                this.PrintToken();
                                this.PrintSpace();
                            }
                        }
                        else if (this._lastType == TokenType.EndBlock) {
                            this.PrintToken();
                            this.PrintNewLine();
                        }
                        else {
                            if (this._currentMode == TsMode.Block && !this._isImportBlock) {
                                this.PrintToken();
                                if (genericsDepth > 0) {
                                    this.PrintSpace();
                                }
                                else {
                                    this.PrintNewLine();
                                }
                            }
                            else {
                                // EXPR od DO_BLOCK
                                this.PrintToken();
                                this.PrintSpace();
                            }
                        }
                        break;
                    }
                    else if (this._tokenText == "--" || this._tokenText == "++") {
                        // unary operators special case
                        if (this._lastText == ";") {
                            if (this._currentMode == TsMode.Block) {
                                // { foo; --i }
                                this.PrintNewLine();
                                startDelim = true;
                                endDelim = false;
                            }
                            else {
                                // space for (;; ++i)
                                startDelim = true;
                                endDelim = false;
                            }
                        }
                        else {
                            if (this._lastText == "{") {
                                this.PrintNewLine();
                            }
                            startDelim = false;
                            endDelim = false;
                        }
                    }
                    else if ((this._tokenText == "!" || this._tokenText == "+" || this._tokenText == "-") && (this._lastText == "return" || this._lastText == "case")) {
                        startDelim = true;
                        endDelim = false;
                    }
                    else if ((this._tokenText == "!" || this._tokenText == "+" || this._tokenText == "-") && this._lastType == TokenType.StartExpression) {
                        // special case handling: if (!a)
                        startDelim = false;
                        endDelim = false;
                    }
                    else if (this._lastType == TokenType.Operator) {
                        startDelim = false;
                        endDelim = false;
                    }
                    else if (this._lastType == TokenType.EndExpression) {
                        startDelim = true;
                        endDelim = true;
                    }
                    else if (this._tokenText == ".") {
                        // decimal digits or object.property
                        startDelim = false;
                        endDelim = false;
                    }
                    else if (this._tokenText == ":") {
                        if ((this.IsTernaryOperation())) {
                            startDelim = true;
                        }
                        else {
                            startDelim = false;
                        }
                    }
                    if (startDelim) {
                        this.PrintSpace();
                    }
                    this.PrintToken();
                    if (endDelim) {
                        this.PrintSpace();
                    }
                    break;
                case TokenType.BlockComment:
                    this.PrintNewLineOrSpace(this._token);
                    this.PrintToken();
                    this.PrintNewLineOrSpace(this._token);
                    break;
                case TokenType.Comment:
                    // print_newline();
                    if (this._lastType == TokenType.StartBlock) {
                        this.PrintNewLine();
                    }
                    else {
                        this.PrintNewLineOrSpace(this._token);
                    }
                    this.PrintToken();
                    this.PrintNewLine();
                    break;
                case TokenType.Unknown:
                    this.PrintToken();
                    break;
            }
            this._lastType = tokenType;
            this._lastText = this._tokenText;
        }
    };
    TsBeautifierInstance.prototype.PrintNewLineOrSpace = function (t) {
        if (t.NewLineCount > 0) {
            this.PrintNewLine();
            return (true);
        }
        this.PrintSpace();
        return (false);
    };
    TsBeautifierInstance.prototype.TrimOutput = function () {
        while (this._output.Length > 0 && (this.SecondToLastChar == ' '.charCodeAt(0) || this.SecondToLastChar == tsutility.StringUtil.CharCodeAt(this._indentString, 0))) {
            this._output.Remove(this._output.Length - 1, 1);
        }
    };
    TsBeautifierInstance.prototype.PrintNewLine = function (ignoreRepeated) {
        if (ignoreRepeated === void 0) { ignoreRepeated = null; }
        if (this._lastText == "return" || this._lastText == "!") {
            return;
        }
        ignoreRepeated = tsutility.Coalesce(ignoreRepeated, function () { return true; });
        this._ifLineFlag = false;
        this.TrimOutput();
        if (this._output.Length == 0) {
            return;
        }
        if (this.SecondToLastChar != '\n'.charCodeAt(0) || !ignoreRepeated) {
            this._output.Append("\n");
        }
        for (var i = 0; i < this._indentLevel; i++) {
            this._output.Append(this._indentString);
        }
    };
    TsBeautifierInstance.prototype.PrintSpace = function () {
        if (this.SecondToLastChar != ' '.charCodeAt(0) && this.SecondToLastChar != '\n'.charCodeAt(0) && this.SecondToLastChar != tsutility.StringUtil.CharCodeAt(this._indentString, 0)) {
            this._output.Append(' '.charCodeAt(0));
        }
    };
    TsBeautifierInstance.prototype.PrintToken = function () {
        this._output.Append(this._tokenText);
    };
    TsBeautifierInstance.prototype.Indent = function () {
        this._indentLevel++;
    };
    TsBeautifierInstance.prototype.Unindent = function () {
        if (this._indentLevel > 0) {
            this._indentLevel--;
        }
    };
    TsBeautifierInstance.prototype.RemoveIndent = function () {
        if (this._output.Length > 0 && this.SecondToLastChar == tsutility.StringUtil.CharCodeAt(this._indentString, 0)) {
            this._output.Remove(this._output.Length - 1, 1);
        }
    };
    TsBeautifierInstance.prototype.SetMode = function (mode) {
        this._modes.push(this._currentMode);
        this._currentMode = mode;
    };
    TsBeautifierInstance.prototype.RestoreMode = function () {
        this._doBlockJustClosed = this._currentMode == TsMode.DoBlock;
        this._currentMode = this._modes.pop();
    };
    TsBeautifierInstance.prototype.IsTernaryOperation = function () {
        var level = 0;
        var colonCount = 0;
        for (var i = this._output.Length - 1; i >= 0; i--) {
            switch (tsutility.StringUtil.CharCodeAt(this._output, i)) {
                case ':'.charCodeAt(0):
                    if (level == 0) {
                        colonCount++;
                    }
                    break;
                case '?'.charCodeAt(0):
                    if (level == 0) {
                        if (colonCount == 0) {
                            return (true);
                        }
                        colonCount--;
                    }
                    break;
                case '{'.charCodeAt(0):
                    if (level == 0) {
                        return (false);
                    }
                    level--;
                    break;
                case '('.charCodeAt(0):
                case '['.charCodeAt(0):
                    level--;
                    break;
                case ')'.charCodeAt(0):
                case ']'.charCodeAt(0):
                case '}'.charCodeAt(0):
                    level++;
                    break;
            }
        }
        return (false);
    };
    TsBeautifierInstance.prototype.SkipWhiteSpace = function (retrievedChar, newLineCount) {
        retrievedChar(this.CurrentInputChar);
        newLineCount(0);
        if (this._parserPos >= this._input.length) {
            this.SetToken("", TokenType.EndOfFile, newLineCount());
            return (true);
        }
        while ((this._whitespaceChars.has(retrievedChar()))) {
            if (this._parserPos >= this._input.length) {
                this.SetToken("", TokenType.EndOfFile, newLineCount());
                return (true);
            }
            if (retrievedChar() == '\n'.charCodeAt(0)) {
                newLineCount(newLineCount() + 1);
            }
            retrievedChar(this.CurrentInputChar);
            this._parserPos++;
        }
        return (false);
    };
    TsBeautifierInstance.prototype.GetNextToken = function () {
        // OUT VAR
        var newLineCount = null;
        // OUT VAR
        var retrievedChar = null;
        if ((this.SkipWhiteSpace2(true, function (value) {
            if (value !== undefined) {
                newLineCount = value;
            }
            return newLineCount;
        }, function (value) {
            if (value !== undefined) {
                retrievedChar = value;
            }
            return retrievedChar;
        }))) {
            return;
        }
        //_parserPos++;
        //if (SkipWhiteSpace(out var retrievedChar, out var newLineCount))
        //{
        //    return;
        //}
        var currentString = (tsutility.StringUtil.EnsureChar(retrievedChar));
        if (retrievedChar == '@'.charCodeAt(0)) {
            // OUT VAR
            var newLineCount2_1 = null;
            // OUT VAR
            var nextNonWhiteSpaceChar_1 = null;
            this.SkipWhiteSpace2(false, function (value) {
                if (value !== undefined) {
                    newLineCount2_1 = value;
                }
                return newLineCount2_1;
            }, function (value) {
                if (value !== undefined) {
                    nextNonWhiteSpaceChar_1 = value;
                }
                return nextNonWhiteSpaceChar_1;
            });
            newLineCount += newLineCount2_1;
        }
        var wantedNewline = false;
        if (this._optPreserveNewlines) {
            if (newLineCount > 1) {
                for (var i = 0; i < 2; i++) {
                    this.PrintNewLine(i == 0);
                }
            }
            wantedNewline = newLineCount == 1;
        }
        var isGenerics = false;
        if (retrievedChar == '<'.charCodeAt(0)) {
            if (this.InGenerics) {
                this._genericsDepth++;
                isGenerics = true;
            }
            else {
                // Check for the start of generics
                for (var i = this._parserPos + 1; i < this._input.length; i++) {
                    var cSub = tsutility.StringUtil.CharCodeAt(this._input, i);
                    if (cSub == '>'.charCodeAt(0)) {
                        isGenerics = true;
                        break;
                    }
                    if (!(this._genericsChars.has(cSub))) {
                        break;
                    }
                }
                if (isGenerics) {
                    this._genericsDepth++;
                }
            }
        }
        else if (retrievedChar == '>'.charCodeAt(0) && this._genericsDepth > 0) {
            isGenerics = true;
            this._genericsDepth--;
        }
        if (isGenerics && (this._genericsBracketsChars.has(retrievedChar))) {
            this.SetToken(currentString, TokenType.Generics, newLineCount);
            return;
        }
        if ((this._wordcharChars.has(retrievedChar)) || (retrievedChar == '@'.charCodeAt(0)) && (this._wordcharChars.has(this.CurrentInputChar))) {
            if (this._parserPos < this._input.length) {
                while ((this._wordcharChars.has(this.CurrentInputChar))) {
                    currentString += tsutility.StringUtil.EnsureChar(this.CurrentInputChar);
                    this._parserPos++;
                    if (this._parserPos == this._input.length) {
                        break;
                    }
                }
            }
            if ((this.CurrentInputChar == '-'.charCodeAt(0) || this.CurrentInputChar == '+'.charCodeAt(0)) && this._parserPos != this._input.length && (new RegExp("^[0-9]+[Ee]$", "g").test(currentString))) {
                var sign = this.CurrentInputChar;
                this._parserPos++;
                this.GetNextToken();
                currentString += tsutility.StringUtil.EnsureChar(sign) + this._token.Value;
                this.SetToken(currentString, TokenType.Word, newLineCount);
                return;
            }
            if (currentString == "in") {
                this.SetToken(currentString, TokenType.Operator, newLineCount);
                return;
            }
            if (wantedNewline && this._lastType != TokenType.Operator && !this._ifLineFlag) {
                this.PrintNewLine();
            }
            this.SetToken(currentString, TokenType.Word, newLineCount);
            return;
        }
        if (retrievedChar == '('.charCodeAt(0) || retrievedChar == '['.charCodeAt(0)) {
            this.SetToken(currentString, TokenType.StartExpression, newLineCount);
            return;
        }
        if (retrievedChar == ')'.charCodeAt(0) || retrievedChar == ']'.charCodeAt(0)) {
            this.SetToken(currentString, TokenType.EndExpression, newLineCount);
            return;
        }
        if (retrievedChar == '{'.charCodeAt(0)) {
            if (this._lastText == "import") {
                this._isImportBlock = true;
                this.SetToken(currentString, TokenType.StartImport, newLineCount);
                return;
            }
            this.SetToken(currentString, TokenType.StartBlock, newLineCount);
            return;
        }
        if (retrievedChar == '}'.charCodeAt(0)) {
            if (this._isImportBlock) {
                this._isImportBlock = false;
                this.SetToken(currentString, TokenType.EndImport, newLineCount);
                return;
            }
            this.SetToken(currentString, TokenType.EndBlock, newLineCount);
            return;
        }
        if (retrievedChar == ';'.charCodeAt(0)) {
            this.SetToken(currentString, TokenType.SemiColon, newLineCount);
            return;
        }
        if (retrievedChar == '/'.charCodeAt(0)) {
            var comment = "";
            if (this.CurrentInputChar == '*'.charCodeAt(0)) {
                this._parserPos++;
                if (this._parserPos < this._input.length) {
                    while (!(this.CurrentInputChar == '*'.charCodeAt(0) && tsutility.StringUtil.CharCodeAt(this._input, this._parserPos + 1) > '\0'.charCodeAt(0) && tsutility.StringUtil.CharCodeAt(this._input, this._parserPos + 1) == '/'.charCodeAt(0) && this._parserPos < this._input.length)) {
                        comment += tsutility.StringUtil.EnsureChar(this.CurrentInputChar);
                        this._parserPos++;
                        if (this._parserPos >= this._input.length) {
                            break;
                        }
                    }
                }
                this._parserPos += 2;
                this.SetToken("/*" + comment + "*/", TokenType.BlockComment, newLineCount);
                return;
            }
            if (this.CurrentInputChar == '/'.charCodeAt(0)) {
                comment = currentString;
                while (this.CurrentInputChar != '\x0d'.charCodeAt(0) && this.CurrentInputChar != '\x0a'.charCodeAt(0)) {
                    comment += tsutility.StringUtil.EnsureChar(this.CurrentInputChar);
                    this._parserPos++;
                    if (this._parserPos >= this._input.length) {
                        break;
                    }
                }
                this._parserPos++;
                if (wantedNewline) {
                    this.PrintNewLine();
                }
                this.SetToken(comment, TokenType.Comment, newLineCount);
                return;
            }
        }
        var interpolationAllowed = StringInterpolationKind.None;
        // Allow C# interpolated strings
        if (retrievedChar == '$'.charCodeAt(0) || this._lastText == "$") {
            var lookahead = retrievedChar == '$'.charCodeAt(0) ? 1 : 0;
            var next = (this.At(this._parserPos + lookahead));
            if (next == '@'.charCodeAt(0) || next == '"'.charCodeAt(0)) {
                interpolationAllowed = StringInterpolationKind.CSharp;
                if (lookahead == 1) {
                    this._output.Append(tsutility.StringUtil.EnsureChar(/*5*/ retrievedChar));
                    retrievedChar = this.CurrentInputChar;
                    currentString = (tsutility.StringUtil.EnsureChar(retrievedChar));
                    this._parserPos++;
                }
            }
        }
        if (retrievedChar == '@'.charCodeAt(0) && this.CurrentInputChar == '"'.charCodeAt(0)) {
            this._output.Append(tsutility.StringUtil.EnsureChar(/*5*/ retrievedChar));
            retrievedChar = this.CurrentInputChar;
            currentString = (tsutility.StringUtil.EnsureChar(retrievedChar));
            this._parserPos++;
        }
        var isQuote = retrievedChar == '\''.charCodeAt(0) || retrievedChar == '\\'.charCodeAt(0) || retrievedChar == '`'.charCodeAt(0) || retrievedChar == '"'.charCodeAt(0);
        if ((isQuote || retrievedChar == '/'.charCodeAt(0)) && (this._lastType == TokenType.Word && (this._lastText == "$" || this._lastText == "return" || this._lastText == "from" || this._lastText == "case") || (isQuote && this._lastType == TokenType.Word) || this._lastType == TokenType.StartExpression || this._lastType == TokenType.BlockComment || this._lastType == TokenType.Comment || this._lastType == TokenType.StartBlock || this._lastType == TokenType.EndBlock || this._lastType == TokenType.Operator || this._lastType == TokenType.Generics || this._lastType == TokenType.EndOfFile || this._lastType == TokenType.SemiColon)) {
            var sep = retrievedChar;
            var esc = false;
            var resultingString = new tsutility.StringBuilder(currentString);
            if (this._parserPos < this._input.length) {
                if (sep == '/'.charCodeAt(0)) {
                    var inCharClass = false;
                    while (esc || inCharClass || this.CurrentInputChar != sep) {
                        resultingString.Append(tsutility.StringUtil.EnsureChar(/*5*/ this.CurrentInputChar));
                        if (!esc) {
                            esc = this.CurrentInputChar == '\\'.charCodeAt(0);
                            if (this.CurrentInputChar == '['.charCodeAt(0)) {
                                inCharClass = true;
                            }
                            else if (this.CurrentInputChar == ']'.charCodeAt(0)) {
                                inCharClass = false;
                            }
                        }
                        else {
                            esc = false;
                        }
                        this._parserPos++;
                        if (this._parserPos >= this._input.length) {
                            this.SetToken((resultingString.toString()), TokenType.String, newLineCount);
                            return;
                        }
                    }
                }
                else {
                    if (retrievedChar == '`'.charCodeAt(0)) {
                        interpolationAllowed = StringInterpolationKind.TypeScript;
                    }
                    while (esc || this.CurrentInputChar != sep) {
                        var interpolationActioned = false;
                        switch (interpolationAllowed) {
                            case StringInterpolationKind.CSharp:
                                if ((StringExtensions.StartsWithAt(this._input, "{", this._parserPos)) && !(StringExtensions.StartsWithAt(this._input, "{{", this._parserPos))) {
                                    interpolationActioned = true;
                                }
                                break;
                            case StringInterpolationKind.TypeScript:
                                if ((StringExtensions.StartsWithAt(this._input, "${", this._parserPos))) {
                                    var escapeCount = 0;
                                    for (var i = this._parserPos - 1; i > 0; i--) {
                                        if (tsutility.StringUtil.CharCodeAt(this._input, i) == '\\'.charCodeAt(0)) {
                                            escapeCount++;
                                        }
                                        else {
                                            break;
                                        }
                                    }
                                    if (escapeCount % 2 == 0) {
                                        // Escaped
                                        interpolationActioned = true;
                                    }
                                }
                                break;
                        }
                        if (interpolationActioned) {
                            switch (interpolationAllowed) {
                                case StringInterpolationKind.CSharp:
                                    {
                                        var jsSourceText = (this._input.substr(this._parserPos));
                                        var sub = new TsBeautifierInstance(jsSourceText, this._options, true);
                                        var interpolated = ((tsutility.StringUtil.TrimStart((sub.Beautify()), '{'.charCodeAt(0))).trim());
                                        resultingString.Append("{" + interpolated + "}");
                                        this._parserPos += sub._parserPos;
                                    }
                                    break;
                                case StringInterpolationKind.TypeScript:
                                    {
                                        var jsSourceText = (this._input.substr(this._parserPos + 1));
                                        var sub = new TsBeautifierInstance(jsSourceText, this._options, true);
                                        var interpolated = ((tsutility.StringUtil.TrimStart((sub.Beautify()), '{'.charCodeAt(0))).trim());
                                        resultingString.Append("${" + interpolated + "}");
                                        this._parserPos += sub._parserPos + 1;
                                    }
                                    break;
                            }
                        }
                        else {
                            resultingString.Append(tsutility.StringUtil.EnsureChar(/*5*/ this.CurrentInputChar));
                            if (!esc) {
                                esc = this.CurrentInputChar == '\\'.charCodeAt(0);
                            }
                            else {
                                esc = false;
                            }
                            this._parserPos++;
                        }
                        if (this._parserPos >= this._input.length) {
                            this.SetToken((resultingString.toString()), TokenType.String, newLineCount);
                            return;
                        }
                    }
                }
            }
            this._parserPos += 1;
            resultingString.Append(tsutility.StringUtil.EnsureChar(/*5*/ sep));
            if (sep == '/'.charCodeAt(0)) {
                while (this._parserPos < this._input.length && (this._wordcharChars.has(this.CurrentInputChar))) {
                    resultingString.Append(tsutility.StringUtil.EnsureChar(/*5*/ this.CurrentInputChar));
                    this._parserPos += 1;
                }
            }
            this.SetToken((resultingString.toString()), TokenType.String, newLineCount);
            return;
        }
        if (retrievedChar == '#'.charCodeAt(0)) {
            var sharp = "#";
            if (this._parserPos < this._input.length && (this._digitsChars.has(this.CurrentInputChar))) {
                do {
                    retrievedChar = this.CurrentInputChar;
                    sharp += tsutility.StringUtil.EnsureChar(retrievedChar);
                    this._parserPos += 1;
                } while (this._parserPos < this._input.length && retrievedChar != '#'.charCodeAt(0) && retrievedChar != '='.charCodeAt(0));
                if (retrievedChar == '#'.charCodeAt(0)) {
                    this.SetToken(sharp, TokenType.Word, newLineCount);
                    return;
                }
                this.SetToken(sharp, TokenType.Operator, newLineCount);
                return;
            }
        }
        if (retrievedChar == '<'.charCodeAt(0) && (this._input.substr(this._parserPos - 1, 3)) == "<!--") {
            this._parserPos += 3;
            this.SetToken("<!--", TokenType.Comment, newLineCount);
            return;
        }
        if (retrievedChar == '-'.charCodeAt(0) && (this._input.substr(this._parserPos - 1, 2)) == "-->") {
            this._parserPos += 2;
            if (wantedNewline) {
                this.PrintNewLine();
            }
            this.SetToken("-->", TokenType.Comment, newLineCount);
            return;
        }
        if ((this._punctuation.has(currentString))) {
            while (this._parserPos < this._input.length && (this._punctuation.has(currentString + tsutility.StringUtil.EnsureChar(this.CurrentInputChar)))) {
                currentString += tsutility.StringUtil.EnsureChar(this.CurrentInputChar);
                this._parserPos += 1;
                if (this._parserPos >= this._input.length) {
                    break;
                }
            }
            this.SetToken(currentString, TokenType.Operator, newLineCount);
            return;
        }
        this.SetToken(currentString, TokenType.Unknown, newLineCount);
    };
    TsBeautifierInstance.prototype.SkipWhiteSpace2 = function (skipFirst, newLineCount, retrievedChar) {
        newLineCount(0);
        if (this._parserPos >= this._input.length) {
            this.SetToken("", TokenType.EndOfFile, newLineCount());
            retrievedChar('\n'.charCodeAt(0));
            return (true);
        }
        retrievedChar(this.CurrentInputChar);
        if (skipFirst) {
            this._parserPos++;
        }
        while ((this._whitespaceChars.has(retrievedChar()))) {
            if (this._parserPos >= this._input.length) {
                this.SetToken("", TokenType.EndOfFile, newLineCount());
                return (true);
            }
            if (retrievedChar() == '\n'.charCodeAt(0)) {
                newLineCount(newLineCount() + 1);
            }
            retrievedChar(this.CurrentInputChar);
            this._parserPos++;
        }
        return (false);
    };
    TsBeautifierInstance.prototype.SetToken = function (token, tokenType, newLineCount) {
        this._token.NewLineCount = newLineCount;
        this._token.Value = token;
        this._token.TokenType = tokenType;
    };
    TsBeautifierInstance.prototype.At = function (position) {
        if (position > this._input.length - 1) {
            return (null);
        }
        return (tsutility.StringUtil.CharCodeAt(this._input, position));
    };
    TsBeautifierInstance.prototype.Beautify = function () {
        this.Parse();
        return (this._output.toString());
    };
    TsBeautifierInstance.prototype.toJSON = function () {
        return tsutility.Serialization.PrepareForJson(this, TsBeautifierInstance);
    };
    TsBeautifierInstance.GenericTypeParameters = [];
    TsBeautifierInstance.ClassName = "TsBeautifierInstance";
    TsBeautifierInstance.ClassNameType = TsBeautifierInstance;
    TsBeautifierInstance.WhitespaceChars = "\n\r\t ";
    TsBeautifierInstance.WordChars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_$";
    TsBeautifierInstance.Chars = "0123456789";
    TsBeautifierInstance.GenericsChars = "<>";
    return TsBeautifierInstance;
}());
var StringInterpolationKind;
(function (StringInterpolationKind) {
    StringInterpolationKind[StringInterpolationKind["None"] = 1] = "None";
    StringInterpolationKind[StringInterpolationKind["CSharp"] = 2] = "CSharp";
    StringInterpolationKind[StringInterpolationKind["TypeScript"] = 3] = "TypeScript";
})(StringInterpolationKind || (StringInterpolationKind = {}));
var TsMode;
(function (TsMode) {
    TsMode[TsMode["Block"] = 0] = "Block";
    TsMode[TsMode["Expression"] = 1] = "Expression";
    TsMode[TsMode["DoBlock"] = 2] = "DoBlock";
})(TsMode || (TsMode = {}));
var TokenType;
(function (TokenType) {
    TokenType[TokenType["Comment"] = 0] = "Comment";
    TokenType[TokenType["Operator"] = 1] = "Operator";
    TokenType[TokenType["Unknown"] = 2] = "Unknown";
    TokenType[TokenType["EndBlock"] = 3] = "EndBlock";
    TokenType[TokenType["EndOfFile"] = 4] = "EndOfFile";
    TokenType[TokenType["StartExpression"] = 5] = "StartExpression";
    TokenType[TokenType["StartBlock"] = 6] = "StartBlock";
    TokenType[TokenType["EndExpression"] = 7] = "EndExpression";
    TokenType[TokenType["Word"] = 8] = "Word";
    TokenType[TokenType["StartImport"] = 9] = "StartImport";
    TokenType[TokenType["EndImport"] = 10] = "EndImport";
    TokenType[TokenType["SemiColon"] = 11] = "SemiColon";
    TokenType[TokenType["String"] = 12] = "String";
    TokenType[TokenType["Generics"] = 13] = "Generics";
    TokenType[TokenType["BlockComment"] = 14] = "BlockComment";
})(TokenType || (TokenType = {}));
var Token = /** @class */ (function () {
    function Token(token, tokenType, newLineCount) {
        if (newLineCount === void 0) { newLineCount = 0; }
        this._Token_NewLineCount = 0;
        this.Value = token;
        this.TokenType = tokenType;
        this.NewLineCount = newLineCount;
    }
    Token.FunctionsDeclared = function () {
        return new Array("get_Value", "set_Value", "get_TokenType", "set_TokenType", "get_NewLineCount", "set_NewLineCount");
    };
    Token.PropertiesDeclared = function () {
        return new Array(new tsutility.PropertyInfo("_Token_Value", Token, tsutility.TypeMetadata.Parse("string"), false, false), new tsutility.PropertyInfo("_Token_TokenType", Token, tsutility.TypeMetadata.Parse("TokenType"), false, false), new tsutility.PropertyInfo("_Token_NewLineCount", Token, tsutility.TypeMetadata.Parse("number"), false, false), new tsutility.PropertyInfo("<Value>k__BackingField", Token, tsutility.TypeMetadata.Parse("System.String"), false, true), new tsutility.PropertyInfo("Value", Token, tsutility.TypeMetadata.Parse("System.String"), true, false), new tsutility.PropertyInfo("<TokenType>k__BackingField", Token, tsutility.TypeMetadata.Parse("TsBeautify.TokenType"), false, true), new tsutility.PropertyInfo("TokenType", Token, tsutility.TypeMetadata.Parse("TsBeautify.TokenType"), true, false), new tsutility.PropertyInfo("<NewLineCount>k__BackingField", Token, tsutility.TypeMetadata.Parse("System.Int32"), false, true), new tsutility.PropertyInfo("NewLineCount", Token, tsutility.TypeMetadata.Parse("System.Int32"), true, false));
    };
    Object.defineProperty(Token.prototype, "Value", {
        get: function () {
            return this.Token_ValueGetter();
        },
        set: function (value) {
            this.Token_ValueSetter(value);
        },
        enumerable: true,
        configurable: true
    });
    Token.prototype.Token_ValueGetter = function () {
        return this._Token_Value;
    };
    Token.prototype.Token_ValueSetter = function (value) {
        this._Token_Value = value;
    };
    Object.defineProperty(Token.prototype, "TokenType", {
        get: function () {
            return this.Token_TokenTypeGetter();
        },
        set: function (value) {
            this.Token_TokenTypeSetter(value);
        },
        enumerable: true,
        configurable: true
    });
    Token.prototype.Token_TokenTypeGetter = function () {
        return this._Token_TokenType;
    };
    Token.prototype.Token_TokenTypeSetter = function (value) {
        this._Token_TokenType = value;
    };
    Object.defineProperty(Token.prototype, "NewLineCount", {
        get: function () {
            return this.Token_NewLineCountGetter();
        },
        set: function (value) {
            this.Token_NewLineCountSetter(value);
        },
        enumerable: true,
        configurable: true
    });
    Token.prototype.Token_NewLineCountGetter = function () {
        return this._Token_NewLineCount;
    };
    Token.prototype.Token_NewLineCountSetter = function (value) {
        this._Token_NewLineCount = value;
    };
    Token.prototype.toJSON = function () {
        return tsutility.Serialization.PrepareForJson(this, Token);
    };
    Token.GenericTypeParameters = [];
    Token.ClassName = "Token";
    Token.ClassNameType = Token;
    return Token;
}());
__TsBeautify_Types_typeLoaded();

var TsBeautifier = /** @class */ (function () {
    function TsBeautifier(options) {
        if (options === void 0) { options = null; }
        this.Options = tsutility.Coalesce(options, function () { return new TsBeautifyOptions(); });
    }
    TsBeautifier.FunctionsDeclared = function () {
        return new Array("get_Options", "set_Options", "Configure", "Beautify");
    };
    TsBeautifier.PropertiesDeclared = function () {
        return new Array(new tsutility.PropertyInfo("_TsBeautifier_Options", TsBeautifier, tsutility.TypeMetadata.Parse("TsBeautifyOptions"), false, false), new tsutility.PropertyInfo("<Options>k__BackingField", TsBeautifier, tsutility.TypeMetadata.Parse("TsBeautify.TsBeautifyOptions"), false, true), new tsutility.PropertyInfo("Options", TsBeautifier, tsutility.TypeMetadata.Parse("TsBeautify.TsBeautifyOptions"), true, false));
    };
    Object.defineProperty(TsBeautifier.prototype, "Options", {
        get: function () {
            return this.TsBeautifier_OptionsGetter();
        },
        set: function (value) {
            this.TsBeautifier_OptionsSetter(value);
        },
        enumerable: true,
        configurable: true
    });
    TsBeautifier.prototype.TsBeautifier_OptionsGetter = function () {
        return this._TsBeautifier_Options;
    };
    TsBeautifier.prototype.TsBeautifier_OptionsSetter = function (value) {
        this._TsBeautifier_Options = value;
    };
    TsBeautifier.prototype.Configure = function (configure) {
        configure(this.Options);
        return this;
    };
    TsBeautifier.prototype.Beautify = function (typescript) {
        try {
            var parser = new TsBeautifierInstance(typescript, this.Options);
            return (parser.Beautify());
        }
        catch (err) {
            return (typescript);
        }
    };
    TsBeautifier.prototype.toJSON = function () {
        return tsutility.Serialization.PrepareForJson(this, TsBeautifier);
    };
    TsBeautifier.GenericTypeParameters = [];
    TsBeautifier.ClassName = "TsBeautifier";
    TsBeautifier.ClassNameType = TsBeautifier;
    return TsBeautifier;
}());
__TsBeautify_Types_typeLoaded();

exports.DummyClass = DummyClass;
exports.StringExtensions = StringExtensions;
exports.TsBeautifier = TsBeautifier;
exports.TsBeautifyOptions = TsBeautifyOptions;
