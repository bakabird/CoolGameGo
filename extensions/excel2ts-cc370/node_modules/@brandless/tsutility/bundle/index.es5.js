var MapUtil = /** @class */ (function () {
    function MapUtil() {
    }
    MapUtil.TryGetValue = function (map, key, result) {
        var item = map.get(key);
        if (item != null) {
            result(item);
            return true;
        }
        return false;
    };
    return MapUtil;
}());

var Guid = /** @class */ (function () {
    function Guid() {
    }
    Guid.NewGuid = function () {
        if (!Guid.lut) {
            Guid.lut = new Array();
            for (var i = 0; i < 256; i++) {
                Guid.lut[i] = (i < 16 ? '0' : '') + (i).toString(16);
            }
        }
        var lut = Guid.lut;
        var d0 = Math.random() * 0xffffffff | 0;
        var d1 = Math.random() * 0xffffffff | 0;
        var d2 = Math.random() * 0xffffffff | 0;
        var d3 = Math.random() * 0xffffffff | 0;
        return lut[d0 & 0xff] + lut[d0 >> 8 & 0xff] + lut[d0 >> 16 & 0xff] + lut[d0 >> 24 & 0xff] + '-' + lut[d1 & 0xff] + lut[d1 >> 8 & 0xff] + '-' + lut[d1 >> 16 & 0x0f | 0x40] + lut[d1 >> 24 & 0xff] + '-' + lut[d2 & 0x3f | 0x80] + lut[d2 >> 8 & 0xff] + '-' + lut[d2 >> 16 & 0xff] + lut[d2 >> 24 & 0xff] + lut[d3 & 0xff] + lut[d3 >> 8 & 0xff] + lut[d3 >> 16 & 0xff] + lut[d3 >> 24 & 0xff];
        //           // Public Domain/MIT
        // var d = new Date().getTime();
        // if (typeof performance !== "undefined" && typeof performance.now === "function") {
        //     d += performance.now(); //use high-precision timer if available
        // }
        // return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,
        //     function(c) {
        //         const r = (d + Math.random() * 16) % 16 | 0;
        //         d = Math.floor(d / 16);
        //         return (c === "x" ? r : (r & 0x3 | 0x8)).toString(16);
        //     });
    };
    Guid.Empty = "00000000-0000-0000-0000-000000000000";
    Guid.lut = null;
    return Guid;
}());

var TypeName = /** @class */ (function () {
    function TypeName() {
    }
    TypeName.GetUniqueTypeInfo = function (type) {
        var key = "__TsName";
        var keyValue = type[key];
        if (keyValue) {
            if (keyValue.type !== type) {
                type[key] = TypeName.NewTypeInfo(type);
                return type[key];
            }
            else {
                return keyValue;
            }
        }
        type[key] = TypeName.NewTypeInfo(type);
        return type[key];
    };
    TypeName.UpdateTypeInfo = function (type) {
        var info = TypeName.GetUniqueTypeInfo(type);
        var className = TypeName.GetClassName(type);
        info.className = className;
        info.name = className || info.temporalName;
        return info;
    };
    TypeName.NewTypeInfo = function (type) {
        var className = TypeName.GetClassName(type);
        var temporalName = Guid.NewGuid();
        return {
            type: type,
            temporalName: temporalName,
            className: className,
            typeName: type.name,
            name: className || temporalName
        };
    };
    TypeName.GetClassName = function (type) {
        var className = null;
        var classNameType = type["ClassNameType"];
        if (classNameType === type) {
            className = type["ClassName"];
        }
        return className;
    };
    TypeName.GetUniqueTypeName = function (type) {
        return TypeName.GetUniqueTypeInfo(type).temporalName;
    };
    return TypeName;
}());

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spreadArray(to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || from);
}

var Collection = /** @class */ (function (_super) {
    __extends(Collection, _super);
    function Collection() {
        var initialItems = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            initialItems[_i] = arguments[_i];
        }
        _super.call(this) || this;
        return new (Collection_.bind.apply(Collection_, __spreadArray([void 0], __read(initialItems), false)))();
    }
    return Collection;
}(Array));
var Collection_ = /** @class */ (function () {
    function Collection_() {
        var _this = this;
        var initialItems = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            initialItems[_i] = arguments[_i];
        }
        Array.prototype.push.apply(this, initialItems);
        return new Proxy(this, {
            get: function (obj, key) {
                var keyType = typeof (key);
                if (keyType === "number" || (keyType === 'string' && (Number.isInteger(Number(key))))) {
                    var result = _this.$get$(keyType === "number" ? key : parseInt(key));
                    if (result !== Collection_._noReturn) {
                        return result;
                    }
                }
                return obj[key];
            },
            set: function (obj, key, value) {
                var keyType = typeof (key);
                if (keyType === "number" || (keyType === 'string' && (Number.isInteger(Number(key))))) {
                    var result = _this.$set$(keyType === "number" ? key : parseInt(key), value);
                    if (result === Collection_._noReturn) {
                        obj[key] = value;
                    }
                }
                else {
                    obj[key] = value;
                }
                return true;
            }
        });
    }
    Collection_.prototype.$get$ = function (index) {
        return Collection_._noReturn;
    };
    Collection_.prototype.$set$ = function (index, value) {
        return Collection_._noReturn;
    };
    Collection_._noReturn = {};
    return Collection_;
}());
Object.setPrototypeOf(Collection_.prototype, Array.prototype);
Object.setPrototypeOf(Collection.prototype, Collection_.prototype);

var StackTracePoint = /** @class */ (function () {
    function StackTracePoint() {
        this.IsExternal = false;
        this.TotalTime = 0;
        this.CallCount = 0;
        this.Children = {};
    }
    return StackTracePoint;
}());
var Profiling = /** @class */ (function () {
    function Profiling() {
    }
    Profiling.Record = function (isExternal, className, methodName, action) {
        if (!Profiling.Enabled) {
            return action();
        }
        var key = "".concat(className, ".").concat(methodName);
        if (Profiling.StackPoint == null) {
            Profiling.StackPoint = Profiling.Log[key];
            if (!Profiling.StackPoint) {
                Profiling.StackPoint = new StackTracePoint();
                Profiling.StackPoint.ClassName = className;
                Profiling.StackPoint.IsExternal = isExternal;
                Profiling.StackPoint.MethodName = methodName;
                Profiling.StackPoint.Key = key;
                Profiling.StackPoint.Path = key;
                Profiling.Log[key] = Profiling.StackPoint;
            }
        }
        else {
            var point = Profiling.StackPoint.Children[key];
            if (!point) {
                point = new StackTracePoint();
                point.ClassName = className;
                point.MethodName = methodName;
                point.IsExternal = isExternal;
                point.ParentPath = Profiling.StackPoint.Path;
                point.Key = key;
                point.Path = point.ParentPath + " > " + point.Key;
                Profiling.StackPoint.Children[key] = point;
            }
            Profiling.StackPoint = point;
        }
        Profiling.Lookup[Profiling.StackPoint.Path] = Profiling.StackPoint;
        var startTime = new Date();
        var result = action();
        Profiling.RecordResult(Profiling.StackPoint, startTime);
        Profiling.StackPoint = Profiling.Lookup[Profiling.StackPoint.ParentPath];
        return result;
    };
    Profiling.RecordAsync = function (isExternal, className, methodName, action) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, Profiling.Record(isExternal, className, methodName, action)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    Profiling.RecordResult = function (stackPoint, startTime) {
        var endTime = new Date();
        var milliseconds = endTime.getTime() - startTime.getTime(); //Math.abs((startTime.getTime() - endTime.getTime()) / 1000);
        stackPoint.CallCount++;
        stackPoint.TotalTime += milliseconds;
        var flat = Profiling.LogFlat[stackPoint.Key];
        if (!flat) {
            flat = new StackTracePoint();
            flat.IsExternal = stackPoint.IsExternal;
            flat.ClassName = stackPoint.ClassName;
            flat.MethodName = stackPoint.MethodName;
            flat.Key = stackPoint.Key;
            flat.CallCount = stackPoint.CallCount;
            flat.TotalTime = stackPoint.TotalTime;
            Profiling.LogFlat[stackPoint.Key] = flat;
        }
        else {
            flat.CallCount++;
            flat.TotalTime += milliseconds;
        }
    };
    Profiling.Enabled = true;
    Profiling.Log = {};
    Profiling.LogFlat = {};
    Profiling.Lookup = {};
    Profiling.StackTrace = new Array();
    Profiling.StackPoint = null;
    return Profiling;
}());

var TypeOf = /** @class */ (function () {
    function TypeOf() {
    }
    TypeOf.IsInstanceOfType = function (obj, type) {
        if (obj == null || type == null) {
            return false;
        }
        if (type instanceof TypeContainer) {
            type = type.type;
        }
        return obj instanceof type || (obj.constructor.prototype === type.constructor.prototype && obj.constructor.prototype.name !== "");
    };
    TypeOf.IsInstanceOf = function (obj, name) {
        if (obj == null) {
            return false;
        }
        var objType = obj.constructor;
        while (true) {
            if (objType === Object || !objType) {
                break;
            }
            if (objType && typeof objType.InterfacesImplemented === "function") {
                var arr = objType.InterfacesImplemented();
                if (arr && arr.constructor === Array) {
                    for (var i = 0; i < arr.length; i++) {
                        if (arr[i] === name) {
                            return true;
                        }
                    }
                }
            }
            objType = Object.getPrototypeOf(objType);
        }
        return false;
    };
    TypeOf.Interface = function (name) {
        var inter = TypeOf.interfaceLookup[name];
        if (inter) {
            return inter;
        }
        inter = new Interface(name);
        TypeOf.interfaceLookup[name] = inter;
        return inter;
    };
    TypeOf.interfaceLookup = {};
    return TypeOf;
}());

//import { Type } from "./TypeDefinition";
var EnumValue = /** @class */ (function () {
    function EnumValue(Name, Value, EnumType) {
        this.Name = Name;
        this.Value = Value;
        this.EnumType = EnumType;
    }
    return EnumValue;
}());
var EnumValueCollection = /** @class */ (function (_super) {
    __extends(EnumValueCollection, _super);
    function EnumValueCollection(EnumType) {
        var _this = _super.call(this) || this;
        _this.EnumType = EnumType;
        TypeInfo.SetPrototypeOf(_this, EnumValueCollection.prototype);
        return _this;
    }
    EnumValueCollection.prototype.toString = function () {
        return Enum.ConvertToString(this.EnumType, this);
    };
    return EnumValueCollection;
}(Collection));
var Enum = /** @class */ (function (_super) {
    __extends(Enum, _super);
    function Enum(Values) {
        var _this = _super.call(this) || this;
        _this.Values = Values;
        TypeInfo.SetPrototypeOf(_this, Enum.prototype);
        return _this;
    }
    Object.defineProperty(Enum.prototype, "Entries", {
        get: function () {
            return this._Entries = this._Entries || this.ResolveEntries();
        },
        enumerable: false,
        configurable: true
    });
    Enum.Get = function (values) {
        if (!Enum._EnumMap.has(values)) {
            Enum._EnumMap.set(values, new Enum(values));
        }
        return Enum._EnumMap.get(values);
    };
    Enum.prototype.ResolveEntries = function () {
        return Enum.ResolveEnumEntries(this.Values);
    };
    Enum.ResolveEnumEntries = function (enumType) {
        if (enumType instanceof TypeContainer) {
            enumType = enumType.type;
        }
        if (enumType instanceof Enum) {
            enumType = enumType.Values;
        }
        var arr = new EnumValueCollection(enumType);
        for (var name_1 in enumType) {
            if (Object.prototype.hasOwnProperty.call(enumType, name_1)) {
                if (/^\d+$/.test(name_1)) {
                    arr.push(new EnumValue(enumType[name_1], +name_1, enumType));
                }
            }
        }
        return arr;
    };
    Object.defineProperty(Enum.prototype, "IsEnum", {
        get: function () {
            return true;
        },
        enumerable: false,
        configurable: true
    });
    Enum.prototype.ConvertToString = function (value) {
        if (this.HasFlags) {
            this.GetEntries(value);
        }
        return this.Values[value];
    };
    Enum.ConvertToString = function (enumType, value) {
        if (enumType instanceof TypeContainer) {
            enumType = enumType.type;
        }
        var values = Enum.Flatten(enumType, value);
        var result = "";
        for (var i = 0; i < values.length; i++) {
            result += values[i].Name;
            if (i < values.length - 1) {
                result += ", ";
            }
        }
        return result;
    };
    Enum.prototype.ConvertFromString = function (value) {
        if (!Object.prototype.hasOwnProperty.call(this.Values, value)) {
            throw new Error("No such enum value");
        }
        return this.Values[value];
    };
    Enum.prototype.TryConvertFromString = function (value) {
        return this.Values[value];
    };
    Enum.GetName = function (type, value) {
        if (type instanceof TypeContainer) {
            type = type.type;
        }
        if (typeof type === "function" && typeof type["Values"] === "object") {
            type = type["Values"];
        }
        return type[value];
    };
    Enum.Parse = function (type, value) {
        if (type instanceof TypeContainer) {
            type = type.type;
        }
        if (type instanceof Enum) {
            return Enum.Parse(type.Values, value);
        }
        if (Enum.HasFlags(type)) {
            var values = value.split(",");
            var result_1 = 0;
            for (var i = 0; i < values.length; i++) {
                var name_2 = (values[i] || "").trim();
                if (name_2) {
                    result_1 |= type[name_2];
                }
            }
            return result_1;
        }
        var result = type[value];
        return result == null ? null : result;
    };
    Enum.SetHasFlags = function (enumType) {
        if (enumType instanceof TypeContainer) {
            enumType = enumType.type;
        }
        Object.defineProperty(enumType, "hasFlags", {
            value: true,
            writable: false,
            enumerable: false
        });
    };
    Object.defineProperty(Enum.prototype, "HasFlags", {
        get: function () {
            return this.Values["hasFlags"] === true;
        },
        enumerable: false,
        configurable: true
    });
    Enum.HasFlags = function (enumType) {
        if (enumType instanceof TypeContainer) {
            enumType = enumType.type;
        }
        if (enumType instanceof Enum) {
            return enumType.HasFlags;
        }
        return enumType.hasFlags === true;
    };
    Enum.prototype.HasFlag = function (values, flag) {
        return Enum.HasFlag(values, flag);
    };
    Enum.HasFlag = function (values, flag) {
        return (values & flag) === flag;
    };
    Enum.SetFlag = function (values, flag) {
        if (!Enum.HasFlag(values, flag)) {
            return values | flag;
        }
        return values;
    };
    Enum.RemoveFlag = function (values, flag) {
        if (Enum.HasFlag(values, flag)) {
            return values & ~flag;
        }
        return values;
    };
    // public GetEntries2<TValue extends T | number | EnumValue<any> | Array<TValue>>(
    //     value: TValue
    // ) {
    //     if (!Array.isArray(value) && !(typeof value === "number") && !(value instanceof EnumValue)) {
    //         return Enum.Flatten(this, <number><any>value);
    //     }
    //     let flattened = Enum.Flatten(this, value);
    // }
    Enum.prototype.GetEntries = function (value) {
        return Enum.GetEntries(this.Values, value);
    };
    Enum.ToObject = function (enumType, value) {
        return Enum.GetEntries(enumType, +value);
    }; //public static ToString(enumType: any, value: )
    Enum.Flatten = function (enumType, value) {
        if (enumType instanceof TypeContainer) {
            enumType = enumType.type;
        }
        var all = Enum.FlattenInternal(enumType, value, new EnumValueCollection(enumType));
        var final = new EnumValueCollection(enumType);
        var names = new Array();
        for (var i = 0; i < all.length; i++) {
            var entry = all[i];
            if (names.indexOf(entry.Name) === -1) {
                names.push(entry.Name);
                final.push(entry);
            }
        }
        return final;
    };
    Enum.FlattenInternal = function (enumType, value, result) {
        if (Array.isArray(value) || value instanceof Array) {
            for (var i = 0; i < value.length; i++) {
                Enum.FlattenInternal(enumType, value[i], result);
            }
        }
        else if (typeof value === "number") {
            var thisResult = Enum.GetEntries(enumType, value);
            for (var i = 0; i < thisResult.length; i++) {
                result.push(thisResult[i]);
            }
        }
        else if (value["constructor"] === EnumValue) {
            Enum.FlattenInternal(enumType, value.Value, result);
        }
        return result;
    };
    Enum.GetEntries = function (enumType, value) {
        if (enumType instanceof TypeContainer) {
            enumType = enumType.type;
        }
        var entries = Enum.ResolveEnumEntries(enumType);
        var hasFlags = Enum.HasFlags(enumType);
        var matches = new EnumValueCollection(enumType);
        for (var i = 0; i < entries.length; i++) {
            if (hasFlags) {
                if (Enum.HasFlag(value, entries[i].Value)) {
                    matches.push(entries[i]);
                }
            }
            else if (value === entries[i].Value) {
                matches.push(entries[i]);
            }
        }
        return matches;
    };
    Enum._EnumMap = new Map();
    return Enum;
}(Function));

var PropertyInfo = /** @class */ (function () {
    function PropertyInfo(name, declaringType, propertyTypeMetadata, isPublic, jsonSerializeIgnore) {
        if (declaringType === void 0) { declaringType = null; }
        if (propertyTypeMetadata === void 0) { propertyTypeMetadata = null; }
        if (isPublic === void 0) { isPublic = true; }
        if (jsonSerializeIgnore === void 0) { jsonSerializeIgnore = false; }
        this._propertyType = new TypeContainer(PropertyInfo);
        this.GenericTypeArguments = [];
        this.IsPublic = true;
        this.JsonSerializeIgnore = true;
        this.Name = name;
        this.DeclaringType = declaringType;
        this.PropertyTypeMetadata = propertyTypeMetadata;
        this.IsPublic = isPublic;
        this.JsonSerializeIgnore = jsonSerializeIgnore;
    }
    Object.defineProperty(PropertyInfo.prototype, "PropertyType", {
        get: function () {
            if (this.PropertyTypeMetadata == null) {
                return null;
            }
            if (this.PropertyTypeMetadata != null) {
                this._propertyType.nameOverride = this.PropertyTypeMetadata.Name;
                this._propertyType.isGeneric = this.PropertyTypeMetadata.IsGeneric;
            }
            return this._propertyType;
        },
        enumerable: false,
        configurable: true
    });
    PropertyInfo.prototype.GetValue = function (obj) {
        return obj[this.Name];
    };
    PropertyInfo.prototype.SetValue = function (obj, value) {
        return obj[this.Name] = value;
    };
    return PropertyInfo;
}());

var MethodInfo = /** @class */ (function () {
    function MethodInfo(name, declaringType) {
        this.Name = name;
        if (declaringType instanceof TypeContainer) {
            declaringType = declaringType.type;
        }
        this.DeclaringType = declaringType;
    }
    MethodInfo.prototype.Invoke = function (context) {
        var _a;
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        if (context == null) {
            context = this.DeclaringType;
        }
        return (_a = context[this.Name]).apply.apply(_a, __spreadArray([context], __read(args), false));
    };
    return MethodInfo;
}());

var Enumerable = /** @class */ (function () {
    function Enumerable() {
    }
    Enumerable.prototype.Count = function (array, filter) {
        return Enumerable.Count(array, filter);
    };
    Enumerable.prototype.IndexOf = function (array, entity) {
        return Enumerable.IndexOf(array, entity);
    };
    Enumerable.prototype.ToList = function (array) {
        return Enumerable.ToList(array);
    };
    Enumerable.prototype.Any = function (array, filter) {
        return Enumerable.Any(array, filter);
    };
    Enumerable.prototype.All = function (array, filter) {
        return Enumerable.All(array, filter);
    };
    Enumerable.prototype.Where = function (array, filter) {
        return Enumerable.Where(array, filter);
    };
    Enumerable.prototype.Single = function (array, filter) {
        if (filter === void 0) { filter = null; }
        return Enumerable.Single(array, filter);
    };
    Enumerable.prototype.Skip = function (array, amount) {
        return Enumerable.Skip(array, amount);
    };
    Enumerable.prototype.Take = function (array, amount) {
        return Enumerable.Take(array, amount);
    };
    Enumerable.prototype.Select = function (array, filter) {
        if (filter === void 0) { filter = null; }
        return Enumerable.Select(array, filter);
    };
    Enumerable.prototype.SelectMany = function (array, selector) {
        if (selector === void 0) { selector = null; }
        return Enumerable.SelectMany(array, selector);
    };
    Enumerable.prototype.Distinct = function (array) {
        return Enumerable.Distinct(array);
    };
    Enumerable.prototype.OrderBy = function (array, orderFunc) {
        return Enumerable.OrderBy(array, orderFunc);
    };
    Enumerable.prototype.OrderByDescending = function (array, orderFunc) {
        return Enumerable.OrderByDescending(array, orderFunc);
    };
    Enumerable.ToList = function (array) {
        return Enumerable.EnsureIterable(array).slice(0);
    };
    Enumerable.OrderBy = function (array, orderFunc) {
        array = Enumerable.EnsureIterable(array);
        var length = Enumerable.GetLength(array);
        var temp = [];
        for (var i = 0; i < length; i++) {
            temp[i] = [array[i], i];
        }
        temp.sort(function (a, b) {
            var aVal = orderFunc(a[0]);
            var bVal = orderFunc(b[0]);
            if (aVal < bVal) {
                return -1;
            }
            if (aVal > bVal) {
                return 1;
            }
            return a[1] - b[1];
        });
        var copy = [];
        for (var i = 0; i < temp.length; i++) {
            copy[i] = temp[i][0];
        }
        return copy;
    };
    Enumerable.OrderByDescending = function (array, orderFunc) {
        array = Enumerable.EnsureIterable(array);
        var length = Enumerable.GetLength(array);
        var temp = [];
        for (var i = 0; i < length; i++) {
            temp[i] = [array[i], i];
        }
        temp.sort(function (a, b) {
            var aVal = orderFunc(a[0]);
            var bVal = orderFunc(b[0]);
            if (aVal < bVal) {
                return 1;
            }
            if (aVal > bVal) {
                return -1;
            }
            return a[1] - b[1];
        });
        var copy = [];
        for (var i = 0; i < temp.length; i++) {
            copy[i] = temp[i][0];
        }
        return copy;
    };
    Enumerable.IndexOf = function (array, entity) {
        array = Enumerable.EnsureIterable(array);
        var length = Enumerable.GetLength(array);
        for (var i = 0; i < length; i++) {
            if (array[i] == entity) {
                return i;
            }
        }
        return -1;
    };
    Enumerable.Distinct = function (array) {
        array = Enumerable.EnsureIterable(array);
        var length = Enumerable.GetLength(array);
        var arr = new Array();
        for (var i = 0; i < length; i++) {
            var item = array[i];
            if (!Enumerable.Contains(arr, item)) {
                arr.push(item);
            }
        }
        return arr;
    };
    Enumerable.Remove = function (array, entity) {
        var j = 0;
        var found = false;
        while (true) {
            var finished = true;
            for (var i = j; i < array.length; i++) {
                if (array[i] === entity) {
                    array.splice(i, 1);
                    j = i;
                    finished = false;
                    found = true;
                    break;
                }
            }
            if (finished) {
                break;
            }
        }
        return found;
    };
    Enumerable.Count = function (array, filter) {
        if (filter === void 0) { filter = null; }
        var result = Enumerable.IfWhere(array, filter);
        return result.length;
    };
    Enumerable.Sum = function (array, filter) {
        if (filter === void 0) { filter = null; }
        array = Enumerable.EnsureIterable(array);
        var length = Enumerable.GetLength(array);
        var total = 0;
        for (var i = 0; i < length; i++) {
            total += filter(array[i]);
        }
        return total;
    };
    Enumerable.Select = function (array, filter) {
        if (filter === void 0) { filter = null; }
        array = Enumerable.EnsureIterable(array);
        var length = Enumerable.GetLength(array);
        var result = new Array();
        for (var i = 0; i < length; i++) {
            result.push(filter(array[i]));
        }
        return result;
    };
    Enumerable.SelectMany = function (array, selector) {
        if (selector === void 0) { selector = null; }
        array = Enumerable.EnsureIterable(array);
        var length = Enumerable.GetLength(array);
        var result = new Array();
        for (var i = 0; i < length; i++) {
            result.push.apply(result, __spreadArray([], __read(selector(array[i])), false));
        }
        return result;
    };
    Enumerable.Single = function (array, filter) {
        if (filter === void 0) { filter = null; }
        var result = Enumerable.IfWhere(array, filter);
        if (result.length > 1) {
            throw new Error("Too many results returned for Single() query.");
        }
        if (result.length < 1) {
            throw new Error("Too few results returned for Single() query.");
        }
        return result[0];
    };
    Enumerable.SingleOrDefault = function (array, filter) {
        if (filter === void 0) { filter = null; }
        array = Enumerable.IfWhere(array, filter);
        if (array.length < 1) {
            return null;
        }
        if (array.length > 1) {
            throw new Error("More than one entity returned for \"SingleOrDefault\" call");
        }
        return Enumerable.Single(array);
    };
    Enumerable.Skip = function (array, amount) {
        if (Array.isArray(array)) {
            return array.slice(amount);
        }
        array = Enumerable.EnsureIterable(array);
        var length = Enumerable.GetLength(array);
        var result = [];
        for (var i = amount; i < length; i++) {
            result.push(array[i]);
        }
        return result;
    };
    Enumerable.Take = function (array, amount) {
        if (Array.isArray(array)) {
            return array.slice(0, amount);
        }
        array = Enumerable.EnsureIterable(array);
        var result = [];
        var length = Enumerable.GetLength(array);
        for (var i = 0; i < amount && i < length; i++) {
            result.push(array[i]);
        }
        return result;
    };
    Enumerable.First = function (array, filter) {
        if (filter === void 0) { filter = null; }
        var result = Enumerable.IfWhere(array, filter);
        if (result.length < 1) {
            throw new Error("Too few results returned for First() query.");
        }
        return result[0];
    };
    Enumerable.FirstOrDefault = function (array, filter) {
        if (filter === void 0) { filter = null; }
        array = Enumerable.IfWhere(array, filter);
        if (array.length < 1) {
            return null;
        }
        return Enumerable.First(array);
    };
    Enumerable.Last = function (array, filter) {
        if (filter === void 0) { filter = null; }
        var result = Enumerable.IfWhere(array, filter);
        if (result.length < 1) {
            throw new Error("Too few results returned for Last() query.");
        }
        return result[result.length - 1];
    };
    Enumerable.LastOrDefault = function (array, filter) {
        if (filter === void 0) { filter = null; }
        array = Enumerable.IfWhere(array, filter);
        if (array.length < 1) {
            return null;
        }
        return Enumerable.Last(array);
    };
    Enumerable.IfWhere = function (array, filter) {
        if (filter === void 0) { filter = null; }
        if (filter) {
            return Enumerable.Where(array, filter);
        }
        return Enumerable.ToList(array);
    };
    Enumerable.EnsureIterable = function (array) {
        if (!Array.isArray(array)) {
            if (array instanceof Map) {
                return Array.from(array.entries());
            }
            if (array instanceof Collection) {
                return array.slice(0);
            }
            var copy = [];
            var length_1 = Enumerable.GetLength(array);
            for (var i = 0; i < length_1; i++) {
                copy.push(array[i]);
            }
            return copy;
        }
        return array;
    };
    Enumerable.GetLength = function (array) {
        var length = array == null ? 0 : (array["length"] || array["size"]);
        return length;
    };
    Enumerable.Where = function (array, filter) {
        if (!filter) {
            return Enumerable.ToList(array);
        }
        if (Array.isArray(array)) {
            return array.filter(filter);
        }
        var filtered = [];
        array = Enumerable.EnsureIterable(array);
        var length = Enumerable.GetLength(array);
        for (var i = 0; i < length; i++) {
            if (filter(array[i])) {
                filtered.push(array[i]);
            }
        }
        return filtered;
    };
    Enumerable.Cast = function (array) {
        return Enumerable.ToList(array);
    };
    Enumerable.Any = function (array, filter) {
        if (filter === void 0) { filter = null; }
        if (!filter) {
            return Enumerable.GetLength(array) > 0;
        }
        return Enumerable.Where(array, filter).length > 0;
    };
    Enumerable.All = function (array, filter) {
        return Enumerable.Where(array, filter).length === Enumerable.GetLength(array);
    };
    Enumerable.Contains = function (array, entity) {
        return Enumerable.Any(array, function (t) { return t === entity; });
    };
    Enumerable.TypeContains = function (array, entity) {
        return Enumerable.Any(array, function (t) { return TypeInfo.ReferToSameType(t, entity); });
    };
    Enumerable.Concat = function (array1, array2) {
        return Enumerable.EnsureIterable(array1).concat(Enumerable.EnsureIterable(array2));
    };
    return Enumerable;
}());

var StringUtil = /** @class */ (function () {
    function StringUtil() {
    }
    StringUtil.CharCodeAt = function (codeOrString, index) {
        if (!codeOrString) {
            return null;
        }
        if (codeOrString["charCodeAt"] && typeof codeOrString["charCodeAt"] === "function") {
            return codeOrString["charCodeAt"](index);
        }
        if (typeof codeOrString === "string") {
            return codeOrString.charCodeAt(index);
        }
        return codeOrString[index];
    };
    StringUtil.EnsureChar = function (codeOrString) {
        if (typeof codeOrString === "string") {
            return codeOrString;
        }
        return String.fromCharCode(codeOrString);
    };
    StringUtil.SplitAndRemoveEmptyEntries = function (str, splitBy) {
        if (typeof splitBy === "number") {
            splitBy = String.fromCharCode(splitBy);
        }
        if (Array.isArray(splitBy)) {
            var strArray = new Array();
            for (var i_1 = 0; i_1 < splitBy.length; i_1++) {
                var v = splitBy[i_1];
                if (typeof v === "number") {
                    strArray.push(String.fromCharCode(v));
                }
                else {
                    strArray.push(v);
                }
            }
            var tempChar = strArray[0]; // We can use the first token as a temporary join character
            for (var i = 1; i < splitBy.length; i++) {
                str = str.split(strArray[i]).join(tempChar);
            }
            return str.split(tempChar);
        }
        var split = str.split(splitBy);
        return split.filter(function (_) { return !StringUtil.IsNullOrEmpty(_); });
    };
    StringUtil.Replace = function (str, search, replaceWith) {
        if (typeof search === "number") {
            search = String.fromCharCode(search);
        }
        if (typeof replaceWith === "number") {
            replaceWith = String.fromCharCode(replaceWith);
        }
        return str.split(search).join(replaceWith);
    };
    StringUtil.IsNullOrWhiteSpace = function (str) {
        return (str !== null && str !== void 0 ? str : "").trim() === "";
    };
    StringUtil.IsNullOrEmpty = function (str) {
        return (str !== null && str !== void 0 ? str : "") === "";
    };
    StringUtil.TrimStart = function (input, find) {
        var search = StringUtil.EnsureStringFromStringOrCharCode(find);
        while (input && input.length > 0 && input.indexOf(search) === 0) {
            input = input.substr(search.length);
        }
        return input;
    };
    StringUtil.TrimEnd = function (input, find) {
        var search = StringUtil.EnsureStringFromStringOrCharCode(find);
        while (input && input.length > 0 && input.length >= search.length && input.substring(input.length - search.length) === search) {
            input = input.substr(0, input.length - search.length);
        }
        return input;
    };
    StringUtil.EnsureStringFromStringOrCharCode = function (input) {
        if (typeof input == "number") {
            return String.fromCharCode(input);
        }
        return input;
    };
    StringUtil.Trim = function (input, find) {
        return StringUtil.TrimEnd(StringUtil.TrimStart(input, find), find);
    };
    StringUtil.IndexOf = function (source, searchString, comparison) {
        return source.indexOf(searchString);
    };
    StringUtil.ToCharArray = function (source) {
        var strings = source.split('');
        var chars = new Array();
        for (var i = 0; i < strings.length; i++) {
            chars.push(strings[i].charCodeAt(0));
        }
        return chars;
    };
    return StringUtil;
}());

var TypeMetadata = /** @class */ (function () {
    function TypeMetadata(name, isGeneric, genericTypeParameters) {
        if (genericTypeParameters === void 0) { genericTypeParameters = null; }
        this.IsGeneric = false;
        this.Name = name;
        this.IsGeneric = isGeneric;
        this.GenericTypeArguments = genericTypeParameters || [];
    }
    Object.defineProperty(TypeMetadata.prototype, "AccessorName", {
        get: function () {
            return "".concat(this.Name, "Type");
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TypeMetadata.prototype, "GenericTypeParameters", {
        get: function () {
            return this.GenericTypeArguments;
        },
        enumerable: false,
        configurable: true
    });
    TypeMetadata.Parse = function (fullName) {
        var type = new TypeMetadata(null, null);
        var isInBrackets = 0;
        var part = "";
        var genericParts = new Array();
        for (var i = 0; i < fullName.length; i++) {
            if (fullName.charCodeAt(i) == '<'.charCodeAt(0)) {
                if (isInBrackets == 0) {
                    type.Name = part;
                    part = "";
                    isInBrackets++;
                    continue;
                }
                isInBrackets++;
            }
            else if (fullName.charCodeAt(i) == '>'.charCodeAt(0)) {
                isInBrackets--;
                if (isInBrackets == 0) {
                    genericParts.push((part.trim()));
                    part = "";
                    continue;
                }
            }
            if (isInBrackets == 1 && fullName.charCodeAt(i) == ','.charCodeAt(0)) {
                genericParts.push((part.trim()));
                part = "";
                continue;
            }
            part += String.fromCharCode(fullName.charCodeAt(i));
        }
        if (part.length > 2 && part.indexOf("$") === 0 && part[part.length - 1] == "$") {
            part = part.substr(1, part.length - 2);
            type.IsGeneric = true;
        }
        if (!(StringUtil.IsNullOrWhiteSpace(part))) {
            type.Name = part;
        }
        var subTypes = new Array();
        for (var i = 0; i < genericParts.length; i++) {
            subTypes.push(TypeMetadata.Parse(genericParts[i]));
        }
        type.GenericTypeArguments = subTypes;
        return type;
    };
    return TypeMetadata;
}());

var TypeInfo = /** @class */ (function () {
    function TypeInfo() {
    }
    TypeInfo.IsDefined = function (type, attribute, inherit) {
        if (!attribute) {
            return false;
        }
        attribute = attribute.trim();
        if (attribute === "FlagsAttribute") {
            return Enum.HasFlags(type);
        }
        return false;
    };
    TypeInfo.SetPrototypeOf = function (O, proto) {
        if (Object.setPrototypeOf) {
            Object.setPrototypeOf(O, proto);
            return O;
        }
        var magic = '__proto__';
        if (typeof O !== 'object' || O == null) {
            throw new TypeError('can not set prototype on a non-object');
        }
        if (typeof proto !== 'object' && proto != null) {
            throw new TypeError('can only set prototype to an object or null');
        }
        var set;
        try {
            // this works already in Firefox and Safari
            set = Object.getOwnPropertyDescriptor(Object.prototype, magic).set;
            set.call({}, null);
        }
        catch (o_O) {
            if (
            // IE < 11 cannot be shimmed
            Object.prototype !== {}[magic] ||
                // neither can any browser that actually
                // implemented __proto__ correctly
                // (all but old V8 will return here)
                {
                    __proto__: null
                }.__proto__ === void 0
            // this case means null objects cannot be passed
            // through setPrototypeOf in a reliable way
            // which means here a **Sham** is needed instead
            ) {
                for (var prop in proto) {
                    if (!O.hasOwnProperty(prop)) {
                        O[prop] = proto[prop];
                    }
                }
                return O;
            }
            // nodejs 0.8 and 0.10 are (buggy and..) fine here
            // probably Chrome or some old Mobile stock browser
            set =
                function (proto) {
                    O[magic] = proto;
                };
            // please note that this will **not** work
            // in those browsers that do not inherit
            // __proto__ by mistake from Object.prototype
            // in these cases we should probably throw an error
            // or at least be informed about the issue
            // (setPrototypeOf as any)["polyfill"] = setPrototypeOf(
            //     setPrototypeOf({}, null),
            //     Object.prototype
            // ) instanceof Object;
            // setPrototypeOf.polyfill === true means it works as meant
            // setPrototypeOf.polyfill === false means it's not 100% reliable
            // setPrototypeOf.polyfill === undefined
            // or
            // setPrototypeOf.polyfill ==  null means it's not a polyfill
            // which means it works as expected
            // we can even delete Object.prototype.__proto__;
        }
        set.call(O, proto);
        return O;
    };
    TypeInfo.BaseType = function (type) {
        if (!type) {
            return type;
        }
        if (type instanceof TypeContainer) {
            type = type.type;
        }
        var baseType = Object.getPrototypeOf(type);
        if (baseType && typeof baseType === "function") {
            var baseTypeString = baseType.toString();
            if (baseTypeString != null && baseTypeString.trim().split(" ").join("").startsWith("function(") && type.prototype) {
                // Fix for IE10
                baseType = Object.getPrototypeOf(type.prototype);
                if (baseType && baseType.constructor) {
                    baseType = baseType.constructor;
                }
            }
        }
        if (type === baseType) {
            return null;
        }
        return baseType;
    };
    TypeInfo.NameOf = function (type) {
        if (!type) {
            return null;
        }
        if (type instanceof TypeContainer) {
            return type.fullName;
        }
        if (type instanceof TypeMetadata) {
            return type.Name;
        }
        return TypeContainer.Get(type).uniqueName;
        // Delay instantiation of this to avoid circular dependency
        /*



        TypeInfo._nameOfLookup = TypeInfo._nameOfLookup || new Dictionary<any, any>();



        if (!TypeInfo._nameOfLookup.ContainsKey(type)) {



            TypeInfo._nameOfLookup.Set(type, {



                Name: TypeName.GetUniqueTypeName(type),



                Type: type



            });



        }



        return TypeInfo._nameOfLookup.Get(type).Name;



        */
    };
    TypeInfo.GetNameOf = function (type) {
        var ctor = typeof type === "function" ? type : type.constructor;
        var name = ctor.name;
        if (!name && typeof ctor === "function") {
            var result = ctor.toString().trim().match(/^function\s*([^\s(]+)/);
            name = result && result.length > 1 ? result[1] : "";
        } // if (!name) {
        //     throw new Error("Unable to get the name of type \"" + (type === null ? "null" : type.toString()) + "\".");
        // }
        if (name === "Interface" && type.Name) {
            return type.Name;
        }
        if (name === "Function") {
            return type.name;
        }
        return name;
    };
    TypeInfo.IsArray = function (obj) {
        return Array.isArray(obj) || obj instanceof Array;
        //var ctor = obj.constructor;
        //while (true) {
        //    if (ctor === Array) {
        //        return true;
        //    }
        //    // Fix for IE10
        //    if (ctor.constructor && ctor.constructor === Array.constructor) {
        //        return true;
        //    }
        //    ctor = Object.getPrototypeOf(ctor);
        //    if (ctor === Object || !ctor) {
        //        break;
        //    }
        //}
        //return false;
    };
    TypeInfo.IsClass = function (type) {
        var isClass = false;
        try {
            isClass = JSON.stringify(type) === "{}";
        }
        catch (e) { }
        return isClass;
    };
    TypeInfo.IsAssignableFrom = function (to, from) {
        if (from == null) {
            return false;
        }
        if (from instanceof TypeContainer) {
            from = from.type;
        }
        if (to instanceof TypeContainer) {
            to = to.type;
        }
        if (to instanceof Interface && to.Name === "IEnumerable") {
            if (from instanceof Interface && from.Name === "IEnumerable") {
                return true;
            }
            return TypeInfo.IsAssignableFrom(Array, from);
        }
        if (!from.IsAssignableFrom || from.IsAssignableFrom.Type !== from) {
            from.IsAssignableFrom = {
                Lookup: new Map(),
                Type: from
            };
        }
        var isAssignableFrom = from.IsAssignableFrom.Lookup.get(to);
        if (isAssignableFrom == null) {
            from.IsAssignableFrom.Lookup.set(to, TypeInfo.GetIsAssignableFrom(to, from));
        }
        return from.IsAssignableFrom.Lookup.get(to);
    };
    TypeInfo.GetIsAssignableFrom = function (to, from) {
        if (TypeInfo.ReferToSameType(to, from)) {
            return true;
        }
        if (from instanceof TypeContainer) {
            from = from.type;
        }
        if (to instanceof TypeContainer) {
            to = to.type;
        }
        var checkInterfaces = false;
        if (TypeOf.IsInstanceOfType(to, Interface)) {
            checkInterfaces = true;
        }
        if (typeof to !== "function" && to.constructor) {
            to = to.constructor;
        }
        if (typeof from !== "function" && from.constructor) {
            from = from.constructor;
            if (from === Object) {
                return false;
            }
        }
        if (checkInterfaces && typeof from.InterfacesImplemented === "function") {
            var interfacesImplemented = from.InterfacesImplemented();
            if (interfacesImplemented && interfacesImplemented.constructor === Array) {
                for (var i = 0; i < interfacesImplemented.length; i++) {
                    if (interfacesImplemented[i] === to.Name) {
                        return true;
                    }
                }
            }
        }
        if (to !== from) {
            return TypeInfo.IsAssignableFrom(to, TypeInfo.BaseType(from));
        }
        return true;
    };
    TypeInfo.GetType = function (input) {
        if (input == null) {
            return null;
        }
        var type = input.constructor;
        if (type == null) {
            return null;
        }
        type.RuntimePropertiesInput = input;
        if (!type.RuntimeProperties) {
            type.RuntimeProperties = function () {
                if (type !== Object && type.RuntimePropertiesArray) {
                    return type.RuntimePropertiesArray();
                }
                var currentInput = type.RuntimePropertiesInput;
                var lookup = new Map();
                var props = new Array();
                do {
                    props = props.concat(Object.getOwnPropertyNames(currentInput));
                    if (currentInput.constructor === Object) {
                        break;
                    }
                } while (currentInput = Object.getPrototypeOf(currentInput));
                for (var i = 0; i < props.length; i++) {
                    var prop = props[i];
                    if (!lookup.has(prop)) {
                        lookup.set(prop, new PropertyInfo(prop, type));
                    }
                }
                type.RuntimePropertiesArray = function () { return lookup; };
                input.RuntimeProperties = function () { return lookup; };
                return lookup;
            };
        }
        var genericTypeParameters = type["GenericTypeParameters"];
        var genericTypeParameterContainers = [];
        if (genericTypeParameters && Array.isArray(genericTypeParameters)) {
            for (var i = 0; i < genericTypeParameters.length; i++) {
                var p = genericTypeParameters[i];
                var value = input[p.AccessorName];
                if (!value) {
                    genericTypeParameterContainers = [];
                    break;
                }
                genericTypeParameterContainers.push(value);
            }
        }
        return TypeContainer.Get.apply(TypeContainer, __spreadArray([type], __read(genericTypeParameterContainers), false));
    };
    TypeInfo.ReferToSameType = function (leftType, rightType) {
        if ((!leftType && rightType) || (!rightType && leftType)) {
            return false;
        }
        if (!leftType && !rightType) {
            return true;
        }
        var leftName = leftType instanceof TypeContainer ? TypeContainer.GetUniqueTypeContainerName(leftType) : TypeName.GetUniqueTypeName(leftType);
        var rightName = rightType instanceof TypeContainer ? TypeContainer.GetUniqueTypeContainerName(rightType) : TypeName.GetUniqueTypeName(rightType);
        if (!leftName && !rightName) {
            return true;
        }
        if ((!leftName && rightName) || (!rightName && leftName)) {
            return false;
        }
        return leftName.toUpperCase() === rightName.toUpperCase();
    };
    TypeInfo.GetProperty = function (type, name) {
        return new PropertyInfo(name);
    };
    TypeInfo.GetRuntimeProperties = function (type) {
        //let originalType = type;
        if (type instanceof TypeContainer) {
            type = type.type;
        }
        if (typeof type !== "function" && type.constructor) {
            type = type.constructor;
        }
        // if (type[TypeInfo.__resolvedPropertiesKey]) {
        //     return type[TypeInfo.__resolvedPropertiesKey]();
        // }
        //if (type !== Object && type.GetRuntimePropertiesArray) {
        //    return type.GetRuntimePropertiesArray();
        //}
        var res = new Array();
        var dic = new Map();
        var sourceType = type;
        while (true) {
            if (type.PropertiesDeclared && typeof type.PropertiesDeclared === "function") {
                var members = type.PropertiesDeclared();
                if (members && members.constructor === Array) {
                    for (var i = 0; i < members.length; i++) {
                        var member = members[i];
                        if (!dic.has(member.Name)) {
                            dic.set(member.Name, member);
                        }
                    }
                }
            }
            if (type === Object) {
                break;
            }
            type = Object.getPrototypeOf(type);
            if (!type) {
                break;
            }
        }
        if (sourceType.RuntimeProperties && typeof sourceType.RuntimeProperties === "function") {
            var mapping = sourceType.RuntimeProperties();
            if (mapping && mapping.constructor === Map) {
                mapping.forEach(function (entryValue, key) {
                    if (!dic.has(entryValue.Name)) {
                        dic.set(entryValue.Name, entryValue);
                    }
                });
            }
        }
        dic.forEach(function (value, key) {
            res.push(value);
        });
        res = res.filter(function (p) { return p.IsPublic === true; });
        //if (originalType !== Object) {
        //    originalType.GetRuntimePropertiesArray = () => res.slice(0);
        //}
        // sourceType[TypeInfo.__resolvedPropertiesKey] = () => res.slice(0);
        // return sourceType[TypeInfo.__resolvedPropertiesKey]();
        return res.slice(0);
    };
    TypeInfo.GetObjectProperties = function (obj) {
        var res = new Array();
        for (var property in obj) {
            if (obj.hasOwnProperty(property)) {
                res.push(new PropertyInfo(property));
            }
        }
        return res;
    };
    TypeInfo.GetProperties = function (type) {
        type = TypeContainer.Get(type);
        var properties = new Array();
        if (type instanceof TypeContainer) {
            type = type.type;
        }
        while (type !== Object) {
            if (type instanceof TypeContainer) {
                type = type.type;
            }
            if (type.PropertiesDeclared && typeof type.PropertiesDeclared === "function") {
                properties.push.apply(properties, __spreadArray([], __read(type.PropertiesDeclared().filter(function (p) { return p.Name.indexOf(".") === -1; })), false));
                type = TypeInfo.BaseType(type);
            }
        }
        return properties;
    };
    TypeInfo.GetMethod = function (type, name) {
        return new MethodInfo(name, type);
    };
    TypeInfo.GetMethods = function (type) {
        return new Array();
    };
    TypeInfo.GetRuntimeProperty = function (type, name) {
        TypeInfo._propertyMap = TypeInfo._propertyMap || new Map();
        if (!TypeInfo._propertyMap.has(type)) {
            var dic = new Map();
            var typeContainer = TypeContainer.Get(type);
            if (typeContainer.type["PropertiesDeclared"] && typeof typeContainer.type["PropertiesDeclared"] === "function") {
                var properties = TypeInfo.GetProperties(typeContainer);
                for (var i = 0; i < properties.length; i++) {
                    dic.set(properties[i].Name, properties[i]);
                }
                TypeInfo._propertyMap.set(type, dic);
            }
            else {
                TypeInfo._propertyMap.set(type, null);
            }
        }
        var lookup = TypeInfo._propertyMap.get(type);
        if (lookup == null) {
            return new PropertyInfo(name);
        }
        return lookup.get(name);
    };
    TypeInfo.GetRuntimeMethod = function (type, name) {
        return Enumerable.SingleOrDefault(TypeInfo.GetRuntimeMethods(type).filter(function (m) { return m.Name === name; }));
    };
    TypeInfo.GetRuntimeMethods = function (type) {
        if (type instanceof TypeContainer) {
            type = type.type;
        }
        if (typeof type !== "function" && type.constructor) {
            type = type.constructor;
        }
        var res = new Array();
        while (true) {
            if (type.FunctionsDeclared && typeof type.FunctionsDeclared === "function") {
                var members = type.FunctionsDeclared();
                if (members && members.constructor === Array) {
                    for (var i = 0; i < members.length; i++) {
                        res.push(new MethodInfo(members[i], type));
                    }
                }
            }
            type = Object.getPrototypeOf(type);
            if (!type || type === Object) {
                break;
            }
        }
        return res;
    };
    TypeInfo.__resolvedPropertiesKey = "__resolvedProperties";
    return TypeInfo;
}());

var Interface = /** @class */ (function (_super) {
    __extends(Interface, _super);
    function Interface(Name) {
        var _this = _super.call(this) || this;
        _this.Name = Name;
        TypeInfo.SetPrototypeOf(_this, Interface.prototype);
        return _this;
    }
    Object.defineProperty(Interface.prototype, "name", {
        get: function () {
            return this.Name;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Interface.prototype, "IsEnum", {
        get: function () {
            return false;
        },
        enumerable: false,
        configurable: true
    });
    Interface.prototype.IsAssignableFrom = function (type) {
        return false;
    };
    return Interface;
}(Function));

var TypeContainer = /** @class */ (function () {
    function TypeContainer(type) {
        var genericTypeContainers = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            genericTypeContainers[_i - 1] = arguments[_i];
        }
        this.isGeneric = false;
        this.nameOverride = null;
        this._uniqueName = null;
        this._genericTypes = genericTypeContainers;
        this._type = type;
    }
    Object.defineProperty(TypeContainer.prototype, "IsEnum", {
        get: function () {
            return this.type["IsEnum"] === true;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TypeContainer.prototype, "IsArray", {
        get: function () {
            return this.type === Array || (this.type instanceof Interface && this.type.Name == "IEnumerable");
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TypeContainer.prototype, "ClassName", {
        get: function () {
            return this.type["ClassName"];
        },
        set: function (value) {
            var old = this.type["ClassName"];
            this.type["ClassName"] = value;
            this.type["ClassNameType"] = this.type;
            if (old != value) {
                this._uniqueName = null;
                TypeName.UpdateTypeInfo(this.type);
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TypeContainer.prototype, "genericTypes", {
        get: function () {
            return this._genericTypes;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TypeContainer.prototype, "genericTypeParameters", {
        get: function () {
            var parameters = this.type["GenericTypeParameters"];
            if (parameters && parameters.length > 0) {
                return parameters;
            }
            return [];
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TypeContainer.prototype, "type", {
        get: function () {
            return this._type;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TypeContainer.prototype, "uniqueName", {
        get: function () {
            if (!this._uniqueName) {
                this._uniqueName = TypeName.GetUniqueTypeName(this.type);
            }
            return this._uniqueName;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TypeContainer.prototype, "fullUniqueName", {
        get: function () {
            var thisName = this.uniqueName;
            if (this.genericTypes && this.genericTypes.length) {
                thisName = "".concat(thisName, "<").concat(this.genericTypes.map(function (_) { return _.uniqueName; }).join(", "), ">");
            }
            return thisName;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TypeContainer.prototype, "fullName", {
        get: function () {
            var thisName = this.nameOverride || TypeName.GetUniqueTypeInfo(this.type).name;
            if (this.genericTypes && this.genericTypes.length) {
                thisName = "".concat(thisName, "<").concat(this.genericTypes.map(function (_) { return _.fullName; }).join(", "), ">");
            }
            return thisName;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TypeContainer.prototype, "fullRawName", {
        get: function () {
            var thisName = this.nameOverride || this.type.name;
            if (this.genericTypes && this.genericTypes.length) {
                thisName = "".concat(thisName, "<").concat(this.genericTypes.map(function (_) { return _.fullRawName; }).join(", "), ">");
            }
            return thisName;
        },
        enumerable: false,
        configurable: true
    });
    TypeContainer.prototype.MakeGenericType = function () {
        var genericTypes = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            genericTypes[_i] = arguments[_i];
        }
        return TypeContainer.Get.apply(TypeContainer, __spreadArray([this.type], __read(genericTypes), false));
    };
    TypeContainer.GetUniqueName = function (type) {
        var genericTypeContainers = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            genericTypeContainers[_i - 1] = arguments[_i];
        }
        var uniqueId = "";
        if (type instanceof TypeContainer) {
            uniqueId = TypeContainer.GetUniqueTypeContainerName(type);
        }
        else {
            if (typeof type !== "function") {
                type = type.constructor;
            }
            uniqueId = TypeName.GetUniqueTypeName(type);
        }
        if (genericTypeContainers && genericTypeContainers.length) {
            uniqueId = "".concat(uniqueId, "<").concat(genericTypeContainers.map(function (_) { return TypeContainer.GetUniqueTypeContainerName(_); }).join(","), ">");
        }
        return uniqueId;
    };
    TypeContainer.GetUniqueTypeContainerName = function (type) {
        if (type instanceof Interface) {
            return type.Name;
        }
        var genericTypes = type.genericTypes;
        return TypeContainer.GetUniqueName.apply(TypeContainer, __spreadArray([type.type], __read(genericTypes), false));
    };
    TypeContainer.Get = function (type) {
        var genericTypeContainers = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            genericTypeContainers[_i - 1] = arguments[_i];
        }
        if (!type) {
            return null;
        }
        if (type instanceof TypeContainer) {
            return type;
        }
        if (typeof type !== "function") {
            type = type.constructor;
        }
        var genericTypeContainersEnsured = new Array();
        for (var i = 0; i < genericTypeContainers.length; i++) {
            var t = genericTypeContainers[i];
            if (t instanceof TypeContainer) {
                genericTypeContainersEnsured.push(t);
            }
            else {
                var arg = genericTypeContainers[i];
                if (Array.isArray(arg)) {
                    genericTypeContainersEnsured.push(TypeContainer.Get.apply(TypeContainer, __spreadArray([arg[0]], __read(arg.splice(0, 1)), false)));
                }
                else {
                    genericTypeContainersEnsured.push(TypeContainer.Get(arg));
                }
            }
        }
        var uniqueId = TypeContainer.GetUniqueName.apply(TypeContainer, __spreadArray([type], __read(genericTypeContainersEnsured), false));
        TypeContainer._lookup = TypeContainer._lookup || new Map();
        if (TypeContainer._lookup.has(uniqueId)) {
            return TypeContainer._lookup.get(uniqueId);
        }
        var container = new (TypeContainer.bind.apply(TypeContainer, __spreadArray([void 0, type], __read(genericTypeContainersEnsured), false)))();
        TypeContainer._lookup.set(uniqueId, container);
        return container;
    };
    return TypeContainer;
}());

var Serialization = /** @class */ (function () {
    function Serialization() {
    }
    Serialization.PrepareForJson = function (obj, type) {
        var typeAny = type;
        var properties = new Array();
        var baseType = typeAny;
        var useDeclaredProperties = false;
        while (baseType && baseType.PropertiesDeclared && typeof baseType.PropertiesDeclared === "function") {
            useDeclaredProperties = true;
            var thisProperties = baseType.PropertiesDeclared();
            for (var i = 0; i < thisProperties.length; i++) {
                var property = thisProperties[i];
                if (!property.IsPublic || property.JsonSerializeIgnore) {
                    continue;
                }
                var key = property.Name;
                if (properties.indexOf(key) === -1) {
                    properties.push(key);
                }
            }
            baseType = TypeInfo.BaseType(baseType);
        }
        if (useDeclaredProperties) {
            var data = {};
            for (var i = 0; i < properties.length; i++) {
                var key = properties[i];
                data[key] = obj[key];
            }
            return data;
        }
        return obj;
    };
    return Serialization;
}());

var DateUtil = /** @class */ (function () {
    function DateUtil() {
    }
    Object.defineProperty(DateUtil, "Empty", {
        get: function () {
            return new Date("0001-01-01T00:00:00.0+00:00");
        },
        enumerable: false,
        configurable: true
    });
    return DateUtil;
}());

//TsExportIdentifier:Enumerable
var DateTime = /** @class */ (function () {
    function DateTime() {
    }
    DateTime.AddDays = function (date, days) {
        return new Date(date.getDate() + days);
    };
    DateTime.AddHours = function (date, hours) {
        return new Date(date.getTime() + (hours * 60 * 60 * 1000));
    };
    DateTime.AddMinutes = function (date, minutes) {
        return new Date(date.getTime() + (minutes * 60 * 1000));
    };
    DateTime.AddSeconds = function (date, seconds) {
        return new Date(date.getTime() + (seconds * 1000));
    };
    DateTime.AddMilliseconds = function (date, milliseconds) {
        return new Date(date.getTime() + milliseconds);
    };
    return DateTime;
}());

var Nullable = /** @class */ (function () {
    function Nullable() {
    }
    Nullable.GetUnderlyingType = function (type) {
        return type;
    };
    return Nullable;
}());

var ExpressionExtensions = /** @class */ (function () {
    function ExpressionExtensions() {
    }
    ExpressionExtensions.GetValue = function (expression) {
        return expression.GetValue({});
    };
    return ExpressionExtensions;
}());

var BreakException = /** @class */ (function () {
    function BreakException(Return) {
        if (Return === void 0) { Return = undefined; }
        this.Return = Return;
    }
    return BreakException;
}());

var ObjectNullifier = /** @class */ (function () {
    function ObjectNullifier() {
    }
    ObjectNullifier.ClearProperty = function (entity, property) {
        delete entity[property];
        entity[property] = undefined;
    };
    return ObjectNullifier;
}());

var StringBuilder = /** @class */ (function () {
    function StringBuilder(currentString) {
        var _this = this;
        if (currentString === void 0) { currentString = null; }
        this._str = "";
        this.toString = function () {
            return _this._str;
        };
        this._str = currentString || "";
    }
    StringBuilder.prototype.AppendLine = function (line) {
        if (line === void 0) { line = ""; }
        this._str += line + "\n";
        return this;
    };
    StringBuilder.prototype.Append = function (text) {
        if (typeof text === "number") {
            this._str += String.fromCharCode(text);
        }
        else {
            this._str += text;
        }
        return this;
    };
    Object.defineProperty(StringBuilder.prototype, "Length", {
        get: function () {
            return this._str.length;
        },
        enumerable: false,
        configurable: true
    });
    StringBuilder.prototype.charCodeAt = function (index) {
        return this._str.charCodeAt(index);
    };
    StringBuilder.prototype.Remove = function (startIndex, length) {
        var left = this._str.substr(0, startIndex);
        var right = this._str.substr(startIndex + length);
        this._str = left + right;
        return this;
    };
    return StringBuilder;
}());

var Activator = /** @class */ (function () {
    function Activator() {
    }
    Activator.CreateInstance = function (type) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        if (type instanceof TypeContainer) {
            type = type.type;
        }
        return Activator.applyConstruct(type, args);
    };
    Activator.applyConstruct = function (ctor, params) {
        if (params && params.length === 1 && params[0] != null && params[0].constructor === Array) {
            params = params[0];
        }
        if (ctor.constructor && ctor.constructor === Array) {
            return [];
        }
        var obj;
        // Create the object with the desired prototype
        if (typeof ctor === "function" && /^\s*class\s+/.test(ctor.toString())) {
            // ES6
            obj = eval("new ctor(...params)");
            return obj;
        }
        if (typeof Object.create === "function") {
            // ECMAScript 5
            obj = Object.create(ctor.prototype);
        }
        else {
            // Fallback
            obj = makeObjectWithFakeCtor();
        }
        // Set the object's constructor
        obj.constructor = ctor;
        // Apply the constructor function
        var newobj = ctor.apply(obj, params);
        // If a constructor function returns an object, that
        // becomes the return value of `new`, so we handle
        // that here.
        if (typeof newobj === "object" || ctor.name === "Number" || ctor.name === "String" || ctor.name === "Date") {
            obj = newobj;
        }
        // Done!
        return obj;
        // Subroutine for building objects with specific prototypes
        function makeObjectWithFakeCtor() {
            function fakeCtor() { }
            fakeCtor.prototype = ctor.prototype;
            return new fakeCtor();
        }
    };
    return Activator;
}());

var DeepCloner = /** @class */ (function () {
    function DeepCloner() {
    }
    DeepCloner.Clone = function (obj, type) {
        var cache = new Array();
        var json = JSON.stringify(obj, function (key, value) {
            if (typeof value === "object" && value !== null) {
                var index = cache.indexOf(value);
                if (index !== -1) {
                    // Circular reference, create a reference object
                    var refObj = {};
                    refObj[DeepCloner.GuidProperty] = DeepCloner.Guid;
                    refObj[DeepCloner.ReferenceToProperty] = index;
                    return refObj;
                } // Store identity of this reference
                cache.push(value);
                index = cache.indexOf(value);
                value[DeepCloner.ReferenceProperty] = index;
                value[DeepCloner.GuidProperty] = DeepCloner.Guid;
            }
            return value;
        }); // Clean up the original's properties
        for (var i = 0; i < cache.length; i++) {
            delete cache[i][DeepCloner.ReferenceProperty];
            delete cache[i][DeepCloner.GuidProperty];
        }
        cache = null; // Enable garbage collection
        var cloned = JSON.parse(json);
        cache = [];
        var iterate = function (obj) {
            if (obj[DeepCloner.GuidProperty] === DeepCloner.Guid && obj[DeepCloner.ReferenceProperty] >= 0) {
                cache[obj[DeepCloner.ReferenceProperty]] = obj;
                obj[DeepCloner.ReferenceProperty] = undefined;
                obj[DeepCloner.GuidProperty] = undefined;
                delete obj[DeepCloner.ReferenceProperty];
                delete obj[DeepCloner.GuidProperty];
            }
            for (var property in obj) {
                if (obj.hasOwnProperty(property)) {
                    if (typeof obj[property] == "object" && obj[property] != null) {
                        if (obj[property][DeepCloner.GuidProperty] === DeepCloner.Guid && obj[property][DeepCloner.ReferenceToProperty] >= 0) {
                            var ref = cache[obj[property][DeepCloner.ReferenceToProperty]];
                            obj[property] = ref;
                        }
                        else {
                            iterate(obj[property]);
                        }
                    }
                }
            }
        };
        iterate(cloned);
        return cloned;
    };
    DeepCloner.ReferenceToProperty = "__referenceTo";
    DeepCloner.ReferenceProperty = "__reference";
    DeepCloner.GuidProperty = "__guid";
    DeepCloner.Guid = "3e718dd6-f063-4cb8-b9ed-c241e7027902";
    return DeepCloner;
}());

function Coalesce(left, right) {
    return left == null ? right() : left;
}

var queue = new Array();
function __defer(fn) {
    queue.push(fn);
    return null;
}
function __deferred() {
    queue.forEach(function (element) {
        element();
    });
}

var KeyValuePair = /** @class */ (function () {
    function KeyValuePair(key, value) {
        this.Key = key;
        this.Value = value;
    }
    return KeyValuePair;
}());

var TryGetValueResult = /** @class */ (function () {
    function TryGetValueResult() {
    }
    return TryGetValueResult;
}());
var DictionaryUtil = /** @class */ (function () {
    function DictionaryUtil() {
    }
    DictionaryUtil.GetKey = function (key, dictionaryKey) {
        if (key == null) {
            return null;
        }
        if (key instanceof TypeContainer) {
            key = key.type;
        }
        var type = typeof (key);
        switch (type) {
            case "number":
                return "tsutility_dictionary_key_number_" + key;
            case "string":
                // Prefix the key to avoid conflicts with the likes of "toString" etc.
                return "tsutility_dictionary_key_string_" + key;
            case "function":
                return TypeName.GetUniqueTypeName(key);
            case "object":
                {
                    var obj = key;
                    //let k = null;
                    // if(!obj.hasOwnProperty("___dic")){
                    //     //k = DictionaryUtil._objectCount++ + "";
                    //     //obj.___dic = k;
                    // }else{
                    //     k = obj.___dic;
                    // }
                    var k_1 = obj.___dic;
                    if (k_1 === undefined) {
                        k_1 = DictionaryUtil._objectCount++ + "";
                        obj.___dic =
                            function () {
                                return k_1;
                            };
                    }
                    else {
                        k_1 = k_1();
                    }
                    return k_1;
                    // let objectKeyProperty = dictionaryKey + "_obj_key";
                    // let indexer = key[objectKeyProperty];
                    // if (!indexer) {
                    //     let objectProperty = dictionaryKey + "_obj";
                    //     indexer = new DictionaryKey(true, "obj_" + DictionaryUtil._objectCount++);
                    //     key[objectKeyProperty] = indexer;
                    // }
                    // return indexer;
                }
            //return new DictionaryKey(false, dictionaryKey);
        }
        return null;
    };
    DictionaryUtil._objectCount = 0;
    return DictionaryUtil;
}());
var DictionaryItem = /** @class */ (function (_super) {
    __extends(DictionaryItem, _super);
    function DictionaryItem(key, value, Index, LookupKey) {
        var _this = _super.call(this, key, value) || this;
        _this.Index = Index;
        _this.LookupKey = LookupKey;
        _this.Deleted = false;
        return _this;
    }
    return DictionaryItem;
}(KeyValuePair));
var Dictionary = /** @class */ (function (_super) {
    __extends(Dictionary, _super);
    function Dictionary() {
        var _this = _super.call(this) || this;
        _this._internal = {};
        _this._internalByIndex = {};
        _this._keys = null;
        _this._values = null;
        TypeInfo.SetPrototypeOf(_this, Dictionary.prototype);
        _this._key = "dic_" + Dictionary._count++; //Guid.NewGuid().replace(new RegExp("-", 'g'), "_");
        return _this;
    }
    Dictionary.prototype.Keys = function () {
        if (!this._keys) {
            var arr = new Array();
            for (var i = 0; i < this.length; i++) {
                arr.push(this[i].Key);
            }
            this._keys = arr;
        }
        return this._keys;
    };
    Dictionary.prototype.Values = function () {
        if (!this._values) {
            var arr = new Array();
            for (var i = 0; i < this.length; i++) {
                arr.push(this[i].Value);
            }
            this._values = arr;
        }
        return this._values;
    };
    Dictionary.prototype.Clear = function () {
        var copy = this.slice();
        for (var i = 0; i < copy.length; i++) {
            this.Remove(copy[i].Key);
        }
        this.length = 0;
    };
    Dictionary.prototype.ContainsKey = function (key) {
        return this.GetItem(DictionaryUtil.GetKey(key, this._key)) != null;
    };
    Dictionary.prototype.TryGetValue = function (key, result) {
        var item = this.GetItem(DictionaryUtil.GetKey(key, this._key));
        if (item != null) {
            result(item.Value);
            return true;
        }
        return false;
    };
    Dictionary.prototype.TryGetValue2 = function (key, result) {
        var item = this.GetItem(DictionaryUtil.GetKey(key, this._key));
        if (item != null) {
            result.Value = item.Value;
            return true;
        }
        return false;
    };
    Dictionary.prototype.Get = function (key) {
        var item = this.GetItem(DictionaryUtil.GetKey(key, this._key));
        return item == null || item.Deleted ? null : item.Value;
    };
    Dictionary.prototype.GetItem = function (key) {
        var item = this._internal[key];
        if (!item || item.Deleted) {
            return undefined;
        }
        return item;
    };
    Dictionary.prototype.Set = function (key, value) {
        var lookupKey = DictionaryUtil.GetKey(key, this._key);
        var item = this.GetItem(lookupKey);
        if (item) {
            item.Value = value;
        }
        else {
            var kvp = new DictionaryItem(key, value, this.length, lookupKey);
            this._internal[lookupKey] = kvp;
            this[this.length++] = kvp;
            this._keys = null;
            this._values = null;
        }
    };
    Dictionary.prototype.Remove = function (key) {
        var item = this.GetItem(DictionaryUtil.GetKey(key, this._key));
        if (item) {
            this.RemoveItem(item);
            return true;
        }
        return false;
    };
    Dictionary.prototype.RemoveItem = function (item) {
        // if (item.LookupKey.CanBeIndexed) {
        //     delete this._internal[item.LookupKey.Key];
        // }
        // else {
        //     //delete item.Key[item.LookupKey.Key];
        //     // Object.defineProperty(item.Key, item.LookupKey.Key, {
        //     //     value: undefined,
        //     //     enumerable: false
        //     // });
        // }
        item.Deleted = true;
        var itemIndex = item.Index;
        if (this.length > 1) {
            this[itemIndex] = this[this.length - 1];
            this[itemIndex].Index = itemIndex;
        }
        delete this[this.length - 1];
        //delete this._internal[item.LookupKey];
        if (this._keys) {
            if (this.length > 1) {
                this._keys[itemIndex] = this._keys[this.length - 1];
            }
            delete this._keys[this.length - 1];
            if (this._keys.length > 0) {
                this._keys.length--;
            }
        }
        if (this._values) {
            if (this.length > 1) {
                this._values[itemIndex] = this._values[this.length - 1];
            }
            delete this._values[this.length - 1];
            if (this._values.length > 0) {
                this._values.length--;
            }
        }
        if (this.length > 0) {
            this.length--;
        }
    };
    Dictionary._count = 0;
    return Dictionary;
}(Collection));

var EqualityComparer = /** @class */ (function () {
    function EqualityComparer() {
    }
    EqualityComparer.CompareTo = function (left, right) {
        return left < right ? -1 : left > right ? 1 : 0;
    };
    EqualityComparer.Equals = function (left, right) {
        if (left === undefined) {
            left = null;
        }
        if (right === undefined) {
            right = null;
        }
        if (left instanceof Date && right instanceof Date) {
            return left.toString() === right.toString();
        }
        return left === right;
    };
    return EqualityComparer;
}());

var Expression = /** @class */ (function () {
    function Expression() {
    }
    Expression.prototype.GetValue = function (context) {
        return this.Func.apply(context, [context]);
    };
    Expression.Add = function (left, right) {
        var exp = new AddExpression(left, right);
        return exp;
    };
    Expression.Constant = function (value) {
        var exp = new ConstantExpression(value);
        return exp;
    };
    Expression.Parameter = function (type, name) {
        return new ParameterExpression(type, name);
    };
    Expression.Assign = function (left, right) {
        return new AssignExpression(left, right);
    };
    Expression.Property = function (expression, propertyName) {
        return new PropertyExpression(expression, propertyName);
    };
    Expression.Lambda = function (body) {
        var parameterExpressions = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            parameterExpressions[_i - 1] = arguments[_i];
        }
        var fn = Expression.GetLambdaString(body, parameterExpressions);
        var compiled = Expression.Compile(fn);
        return compiled;
        // let fn = function () {
        //     let ctx = {};
        //     for (let i = 0; i < parameterExpressions.length; i++) {
        //         ctx[parameterExpressions[i].Name] = arguments[i];
        //     }
        //     return body.Func.apply(ctx, [ctx]);
        // };
        // return fn;
    };
    Expression.Compile = function (body) {
        return eval(body);
    };
    Expression.GetLambdaString = function (body, parameterExpressions) {
        var fn = "var compiledFunction = function(";
        for (var i = 0; i < parameterExpressions.length; i++) {
            fn += parameterExpressions[i].Name;
            if (i < parameterExpressions.length - 1) {
                fn += ", ";
            }
        }
        fn += ") {\r\n return " + body.Compile() + ";\r\n}\r\ncompiledFunction;";
        return fn;
    };
    return Expression;
}());
var ParameterExpression = /** @class */ (function (_super) {
    __extends(ParameterExpression, _super);
    function ParameterExpression(Type, Name) {
        var _this = _super.call(this) || this;
        _this.Type = Type;
        _this.Name = Name;
        _this.Func = function (context) { return context[Name]; };
        return _this;
    }
    ParameterExpression.prototype.Compile = function () {
        return this.Name;
    };
    return ParameterExpression;
}(Expression));
//exportx class LambdaExpression extends Expression {
//    public Parameters: ParameterExpression[];
//    constructor(public Body: Expression, ...parameters: ParameterExpression[]) {
//        super();
//        this.Parameters = parameters;
//    }
//}
var PropertyExpression = /** @class */ (function (_super) {
    __extends(PropertyExpression, _super);
    function PropertyExpression(Expression, PropertyName) {
        var _this = _super.call(this) || this;
        _this.Expression = Expression;
        _this.PropertyName = PropertyName;
        _this.Func = function (context) { return Expression.GetValue(context)[PropertyName]; };
        return _this;
    }
    PropertyExpression.prototype.Compile = function () {
        return this.Expression.Compile() + "." + this.PropertyName;
    };
    return PropertyExpression;
}(Expression));
var BinaryExpression = /** @class */ (function (_super) {
    __extends(BinaryExpression, _super);
    function BinaryExpression(Left, Right) {
        var _this = _super.call(this) || this;
        _this.Left = Left;
        _this.Right = Right;
        return _this;
    }
    return BinaryExpression;
}(Expression));
var AssignExpression = /** @class */ (function (_super) {
    __extends(AssignExpression, _super);
    function AssignExpression(Left, Right) {
        var _this = _super.call(this, Left, Right) || this;
        _this.Left = Left;
        _this.Right = Right;
        _this.Func = function (context) { return Left.Expression.GetValue(context)[Left.PropertyName] = Right.GetValue(context); };
        return _this;
    }
    AssignExpression.prototype.Compile = function () {
        return this.Left.Compile() + " = " + this.Right.Compile();
    };
    return AssignExpression;
}(BinaryExpression));
var AddExpression = /** @class */ (function (_super) {
    __extends(AddExpression, _super);
    function AddExpression(Left, Right) {
        var _this = _super.call(this, Left, Right) || this;
        _this.Left = Left;
        _this.Right = Right;
        _this.Func = function (context) { return Left.GetValue(context) + Right.GetValue(context); };
        return _this;
    }
    AddExpression.prototype.Compile = function () {
        return this.Left.Compile() + " + " + this.Right.Compile();
    };
    return AddExpression;
}(BinaryExpression));
var ConstantExpression = /** @class */ (function (_super) {
    __extends(ConstantExpression, _super);
    function ConstantExpression(Value) {
        var _this = _super.call(this) || this;
        _this.Value = Value;
        _this.Func = function (context) { return Value; };
        return _this;
    }
    ConstantExpression.prototype.Compile = function () {
        throw new Error("Method not implemented.");
    };
    return ConstantExpression;
}(Expression));

var JavaScript = /** @class */ (function () {
    function JavaScript() {
    }
    JavaScript.Eval = function (javascript) {
        return eval(javascript);
    };
    return JavaScript;
}());

var NotImplementedException = /** @class */ (function (_super) {
    __extends(NotImplementedException, _super);
    function NotImplementedException() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return NotImplementedException;
}(Error));

var NumberConversionResult = /** @class */ (function () {
    function NumberConversionResult(Success, Value) {
        this.Success = Success;
        this.Value = Value;
    }
    return NumberConversionResult;
}());

var NumberConverter = /** @class */ (function () {
    function NumberConverter() {
    }
    NumberConverter.TryConvert = function (value) {
        var result = new NumberConversionResult(false, 0);
        var asNumber = parseInt(value);
        if (!isNaN(asNumber)) {
            result.Value = asNumber;
            result.Success = true;
        }
        return result;
    };
    return NumberConverter;
}());

var Platform = /** @class */ (function () {
    function Platform() {
    }
    Platform.Name = "JavaScript";
    return Platform;
}());

var Regex = /** @class */ (function () {
    function Regex() {
    }
    Regex.Replace = function (input, pattern, replaceWith) {
        return input.replace(pattern, replaceWith);
    };
    return Regex;
}());

var StringComparison;
(function (StringComparison) {
    StringComparison[StringComparison["CurrentCulture"] = 0] = "CurrentCulture";
    StringComparison[StringComparison["CurrentCultureIgnoreCase"] = 1] = "CurrentCultureIgnoreCase";
    StringComparison[StringComparison["InvariantCulture"] = 2] = "InvariantCulture";
    StringComparison[StringComparison["InvariantCultureIgnoreCase"] = 3] = "InvariantCultureIgnoreCase";
    StringComparison[StringComparison["Ordinal"] = 4] = "Ordinal";
    StringComparison[StringComparison["OrdinalIgnoreCase"] = 5] = "OrdinalIgnoreCase";
})(StringComparison || (StringComparison = {}));

//TsExportIdentifier:Ts
var Ts = /** @class */ (function () {
    function Ts() {
    }
    Ts.Enumerable = new Enumerable();
    return Ts;
}());

function SafeCast(type, obj) {
    if (obj == null) {
        return null;
    }
    if (type instanceof TypeContainer) {
        return SafeCast(type.type, obj);
    }
    var name = TypeInfo.NameOf(type);
    if (name === "String") {
        return typeof obj === "string" ? obj : null;
    }
    if (name === "Number") {
        return typeof obj === "number" ? obj : null;
    }
    return TypeInfo.IsAssignableFrom(type, TypeInfo.GetType(obj)) ? obj : null;
    //return obj instanceof type ? (obj as T) : null;
}
function SafeCastToInterface(obj, interfaceDefinition) {
    // TODO: Check if object type implements interface
    if (obj == null) {
        return null;
    }
    if (interfaceDefinition.Name === "IArray" && TypeInfo.IsArray(obj)) {
        return obj;
    }
    if (TypeInfo.GetIsAssignableFrom(interfaceDefinition, TypeInfo.GetType(obj))) {
        return obj;
    }
    return null;
}
function GetValueOf(obj) {
    if (typeof obj === 'object') {
        return obj;
    }
    return (obj == null ? obj : obj.valueOf());
}

export { Activator, AddExpression, AssignExpression, BinaryExpression, BreakException, Coalesce, Collection, ConstantExpression, DateTime, DateUtil, DeepCloner, Dictionary, DictionaryItem, Enum, EnumValue, EnumValueCollection, Enumerable, EqualityComparer, Expression, ExpressionExtensions, GetValueOf, Guid, Interface, JavaScript, KeyValuePair, MapUtil, MethodInfo, NotImplementedException, Nullable, NumberConversionResult, NumberConverter, ObjectNullifier, ParameterExpression, Platform, Profiling, PropertyExpression, PropertyInfo, Regex, SafeCast, SafeCastToInterface, Serialization, StackTracePoint, StringBuilder, StringComparison, StringUtil, TryGetValueResult, Ts, TypeContainer, TypeInfo, TypeMetadata, TypeName, TypeOf, __defer, __deferred };
